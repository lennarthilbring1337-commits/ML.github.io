<!doctype html>
<html lang="de">

<head>
  <meta charset="utf-8">
  <title>ML Destroyer</title>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="libs/p5.min.js"></script>
  <script src="libs/gsap.min.js"></script>
  <style>
    @font-face {
      font-family: "AkUltra";
      src: url("ML/Ak_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "FckUltra";
      src: url("ML/Fck_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "NoiseUltra";
      src: url("ML/Noise_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "RbUltra";
      src: url("ML/Rb_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "TSUUltra";
      src: url("ML/TSU_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "VvUltra";
      src: url("ML/Vv_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "EchoUltra";
      src: url("ML/echo_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "SliceUltra";
      src: url("ML/slice_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "DRNUltra";
      src: url("ML/DRN_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "INKUltra";
      src: url("ML/INK_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "KIDUltra";
      src: url("ML/KID_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "LLOUltra";
      src: url("ML/LLO_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "BlockUltra";
      src: url("ML/block_ultra.otf") format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "SonarUltra";
      src: url("ML/sonar_ultra.otf") format("opentype");
      font-display: swap;
    }

    :root {
      --bg: #ffffff;
      --panel: #f8f8f8;
      --ink: #000000;
      --muted: #666666;
      --stroke: #d8d8d8;
      --accent: #000000;
      --shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
    }

    * {
      box-sizing: border-box;
      font-family: "Space Grotesk", "IBM Plex Sans", system-ui, sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
    }

    header {
      padding: 24px 36px;
      border-bottom: 2px solid var(--stroke);
      display: flex;
      align-items: center;
      gap: 18px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      font-weight: 700;
      background: #fff;
    }

    header img {
      width: 50px;
      height: 50px;
      object-fit: contain;
      filter: grayscale(1);
    }

    header .brand-marquee {
      margin-left: auto;
      font-size: 0.9rem;
      letter-spacing: 0.4em;
      font-family: "AkUltra", "Space Grotesk", sans-serif;
      transition: opacity 0.3s ease;
      opacity: 1;
    }

    #app {
      display: flex;
      height: calc(100vh - 98px);
    }

    #controls {
      width: 360px;
      background: var(--panel);
      border-right: 2px solid var(--stroke);
      padding: 22px;
      overflow-y: auto;
    }

    section {
      margin-bottom: 26px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--stroke);
    }

    h3 {
      margin: 0 0 12px;
      font-size: 11px;
      letter-spacing: 0.28em;
      color: var(--muted);
    }

    label {
      display: block;
      margin: 8px 0 6px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: var(--muted);
    }

    input,
    select {
      width: 100%;
      padding: 11px 13px;
      border: 1px solid var(--stroke);
      border-radius: 0;
      background: white;
      font-size: 13px;
      color: var(--ink);
    }

    input[type=range] {
      padding: 0;
      accent-color: #000;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .row span {
      min-width: 36px;
      text-align: right;
      font-size: 11px;
      color: #888;
    }

    button {
      width: 100%;
      padding: 12px 14px;
      border: 1px solid #000;
      border-radius: 0;
      background: white;
      color: #000;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.12em;
    }

    button:hover {
      background: #000;
      color: #fff;
    }

    #workspace {
      flex: 1;
      padding: 24px;
      display: flex;
      background: #fff;
    }

    #canvas2d {
      flex: 1;
      width: 100%;
      height: 100%;
      background: #fff;
      border: 3px solid #000;
      box-shadow: var(--shadow);
      touch-action: none;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 6px 0;
    }

    li {
      padding: 6px 8px;
      border: 1px solid var(--stroke);
      border-radius: 0;
      margin-bottom: 6px;
      cursor: pointer;
      background: white;
      color: var(--ink);
    }

    li.selected {
      border-color: #000;
      background: #f0f0f0;
    }

    .inline {
      display: flex;
      gap: 8px;
    }

    .note {
      font-size: 11px;
      color: #777;
      margin-top: 6px;
      line-height: 1.4;
    }

    ::selection {
      background: #000;
      color: #fff;
    }
  </style>
</head>

<body>
  <header>
    <img src="logo/ML Logo.png" alt="ML logo">
    <div class="brand-marquee">MONOLINE</div>
  </header>
  <div id="app">
    <aside id="controls">
      <section>
        <h3>Quelle</h3>
        <label>Font (ttf/otf/svg)</label>
        <input type="file" id="fontFile" accept=".ttf,.otf,.svg">
        <div class="note">SVG-Fonts werden automatisch analysiert.</div>
        <label>Text</label>
        <input type="text" id="inputText" value="TYPO LAB">
        <button id="renderBtn" style="margin-top:8px;">Rendern</button>
        <button id="alphabetBtn" style="margin-top:6px;">Alphabet Rendern</button>
        <button id="downloadGlyphs" style="margin-top:6px;">Buchstaben Download</button>
      </section>

      <section>
        <h3>Globale Parameter</h3>
        <label>SchriftgrÃ¶ÃŸe</label>
        <div class="row"><input type="range" id="size" min="20" max="300" value="140"><span id="sizeVal">140</span>
        </div>
        <label>Strichbreite</label>
        <div class="row"><input type="range" id="strokeScale" min="0.2" max="5" step="0.1" value="1"><span
            id="strokeVal">1.0</span></div>
        <label>Tracking</label>
        <div class="row"><input type="range" id="tracking" min="-100" max="200" value="0"><span
            id="trackingVal">0</span></div>
        <label>Zeilenabstand %</label>
        <div class="row"><input type="range" id="lineHeight" min="80" max="200" value="110"><span
            id="lineHeightVal">110</span></div>
        <label style="display:none;">Sampling %</label>
        <div class="row" style="display:none;"><input type="range" id="sampleDetail" min="40" max="200"
            value="100"><span id="sampleDetailVal">100</span></div>
      </section>

      <section>
        <h3>Globale Effekte</h3>
        <label>Typ</label>
        <select id="distortionType">
          <option value="none">none</option>
          <option value="wave">wave</option>
          <option value="zigzag">zigzag</option>
          <option value="noise">noise</option>
          <option value="twist">twist</option>
          <option value="bulge">bulge</option>
          <option value="shear">shear</option>
          <option value="ripple">ripple</option>
          <option value="shockwave">shockwave</option>
          <option value="turbulence">turbulence</option>
          <option value="fracture">fracture</option>
          <option value="rupture">rupture</option>
          <option value="crumble">crumble</option>
          <option value="smear">smear</option>
          <option value="glitch">glitch</option>
          <option value="melt">melt</option>
          <option value="disintegrate">disintegrate</option>
          <option value="implode">implode</option>
          <option value="explode">explode</option>
          <option value="shred">shred</option>
          <option value="void">void</option>
          <option value="cyclone">cyclone</option>
          <option value="gravitywell">gravitywell</option>
          <option value="pulse">pulse</option>
          <option value="crystal">crystal</option>
          <option value="slipstream">slipstream</option>
          <option value="warpfield">warpfield</option>
          <option value="splat">splat</option>
          <option value="fold">fold</option>
          <option value="scramble">scramble</option>
          <option value="storm">storm</option>
          <option value="quake">quake</option>
          <option value="curtain">curtain</option>
          <option value="kaleido">kaleido</option>
          <option value="cluster">cluster</option>
          <option value="tangle">tangle</option>
          <option value="magnetic">magnetic</option>
          <option value="plasma">plasma</option>
          <option value="dust">dust</option>
          <option value="slice">slice</option>
          <option value="swirl">swirl</option>
          <option value="inkblot">inkblot</option>
          <option value="radiate">radiate</option>
          <option value="scatter">scatter</option>
          <option value="sonar">sonar</option>
          <option value="filament">filament</option>
          <option value="ribbons">ribbons</option>
          <option value="perlinflow">perlinflow</option>
          <option value="fractal">fractal</option>
          <option value="tsunami">tsunami</option>
          <option value="circuit">circuit</option>
          <option value="ghost">ghost</option>
          <option value="blaze">blaze</option>
          <option value="nebula">nebula</option>
          <option value="psycho">psycho</option>
          <option value="wormhole">wormhole</option>
          <option value="entropy">entropy</option>
          <option value="liquid">liquid</option>
          <option value="shatter">shatter</option>
          <option value="orbital">orbital</option>
          <option value="lattice">lattice</option>
          <option value="crush">crush</option>
          <option value="spectrum">spectrum</option>
          <option value="helix">helix</option>
          <option value="eruption">eruption</option>
          <option value="gridlock">gridlock</option>
          <option value="anomaly">anomaly</option>
          <option value="splinter">splinter</option>
          <option value="flux">flux</option>
          <option value="detonate">detonate</option>
          <option value="fiber">fiber ðŸ§µ</option>
          <option value="voxel">voxel ðŸŽ®</option>
          <option value="origami">origami ðŸ“„</option>
          <option value="static">static ðŸ“º</option>
          <option value="aurora">aurora ðŸŒŒ</option>
        </select>
        <div id="effectInfo" class="note">WÃ¤hle einen Effekt aus der Library.</div>
        <label>StÃ¤rke</label>
        <div class="row"><input type="range" id="distortionAmount" min="0" max="100" value="20"><span
            id="distortionVal">20</span></div>
        <div class="row" style="margin-top:6px;">
          <input type="checkbox" id="roughenEnabled" style="width:auto;"><span
            style="font-size:12px;color:var(--muted);">Roughen</span>
        </div>
        <label>Roughness</label>
        <div class="row"><input type="range" id="roughness" min="0" max="100" value="20"><span
            id="roughnessVal">20</span></div>
        <label>Geo Break</label>
        <div class="row"><input type="range" id="geometryBreak" min="0" max="100" value="0"><span
            id="geometryBreakVal">0</span></div>
        <label>ZerstÃ¶rung</label>
        <div class="row"><input type="range" id="destruction" min="0" max="100" value="0"><span
            id="destructionVal">0</span></div>
      </section>

      <section>
        <h3>HISTORY</h3>
        <div class="inline">
          <button id="undoBtn">Undo</button>
          <button id="redoBtn">Redo</button>
        </div>
      </section>

      <section>
        <h3>PROJECT</h3>
        <div class="inline">
          <button id="exportProject">Projekt exportieren</button>
          <button id="importProjectBtn">Projekt importieren</button>
        </div>
        <input type="file" id="projectFile" accept=".json" style="margin-top:6px;">
        <button id="exportFontBtn" style="margin-top:6px;">Font exportieren</button>
      </section>
    </aside>

    <main id="workspace">
      <canvas id="canvas2d"></canvas>
    </main>
  </div>

  <script>
    /* --- State & Classes --- */
    class GlyphInstance {
      constructor(id, char, segments, transform, style, effects) {
        this.id = id;
        this.char = char;
        this.segments = segments; // original
        this.transform = transform;
        this.style = style;
        this.effects = effects;
        this.selected = false;
      }
    }

    const state = {
      font: null,
      svgFont: null,
      customFontFamily: null, // For canvas-based rendering
      text: "TYPO LAB",
      size: 140,
      strokeScale: 1,
      tracking: 0,
      lineHeight: 110,
      distortionType: "wave",
      distortionAmount: 20,
      roughenEnabled: false,
      roughness: 20,
      geometryBreak: 0,
      destruction: 0,
      sampleDetail: 100,
      colorPrimary: "#000000",
      backgroundColor: "#ffffff",
      customFontName: "TypoLab Custom"
    };

    const effectDescriptions = {
      none: "Keine Verzerrung â€“ die Glyphen bleiben unverÃ¤ndert.",
      wave: "Horizontale Sinus-Wellen verbiegen die Linien rhythmisch.",
      zigzag: "Jeder zweite Punkt springt nach oben/unten fÃ¼r harte Zacken.",
      noise: "Additiver Random-Offset zerreiÃŸt die Linien leicht chaotisch.",
      twist: "Rotiert Glyphen abhÃ¤ngig vom Abstand zum Zentrum.",
      bulge: "WÃ¶lbt die Form radial nach auÃŸen oder innen.",
      shear: "Schiebt die Glyphen entlang einer Scherachse.",
      ripple: "Konzentrische Wellen pulsieren vom Mittelpunkt aus.",
      shockwave: "Ein Ring schiebt alles zur Seite â€“ wie eine Druckwelle.",
      turbulence: "Mehrlagiger Perlin-Noise verwirbelt die Konturen.",
      fracture: "Simuliert gebrochene Glasscherben mit zufÃ¤lligen VersÃ¤tzen.",
      rupture: "ReiÃŸt Glyphen in versetzte BlÃ¶cke und versprengt sie.",
      crumble: "BrÃ¶selt die Konturen, als wÃ¼rden sie zerfallen.",
      smear: "Zieht Buchstaben entlang der Y-Achse wie verschmierte Farbe.",
      glitch: "Digitale horizontale VersÃ¤tze und SprÃ¼nge.",
      melt: "LÃ¤sst die Form nach unten tropfen und einsacken.",
      disintegrate: "LÃ¶st Teile zufÃ¤llig auf und jittert die Ãœberreste.",
      implode: "Zieht alles aggressiv zum Zentrum.",
      explode: "Sprengt Glyphen radial auseinander.",
      shred: "ZerreiÃŸt Buchstaben in gegeneinander verschobene Streifen.",
      void: "Saugt Striche in ein Loch, das du frei bewegst.",
      cyclone: "Wirbelt alles in eine Spiralbewegung.",
      gravitywell: "Mehrere Schwerkraftpunkte ziehen/stoÃŸen die Linien.",
      pulse: "Sinusbasierter Offset sorgt fÃ¼r vibrierende Buchstaben.",
      crystal: "Kristallisiert Striche zu kantigen Facetten.",
      slipstream: "StrÃ¶mungssimulation mit sanften Kurven.",
      warpfield: "Chaotisches Vektorfeld verdreht die Konturen.",
      splat: "Explodierende Partikel schieÃŸen Striche auseinander.",
      fold: "Spiegelt Teile wie aufgefaltetes Papier.",
      scramble: "Vertauscht Punkte zufÃ¤llig und fÃ¼gt Jitter hinzu.",
      storm: "Starker Seitenwind mit Noise-Gusts.",
      quake: "SchÃ¼ttelt Glyphen horizontal und vertikal.",
      curtain: "LÃ¤sst die Formen wie VorhÃ¤nge nach unten fallen.",
      kaleido: "Segmentiert und spiegelt fÃ¼r kaleidoskopische Muster.",
      cluster: "Zieht Linien zu zufÃ¤lligen Zentren.",
      tangle: "Noise-Vektoren verheddern die Linien.",
      magnetic: "Magnetpole ziehen/stoÃŸen die Konturen.",
      plasma: "Sinus- und Noise-Schwaden erzeugen PlasmaflÃ¤chen.",
      dust: "Partikelhafte AuflÃ¶sung mit starkem Jitter.",
      slice: "Verschiebt horizontale Layer wie geschnittene Folien.",
      swirl: "Kleine Wirbel verzerren die Form mehrfach.",
      inkblot: "Spiegelt zur Mitte und ergÃ¤nzt Tintenflecken.",
      radiate: "Pulse schieben Punkte radial nach auÃŸen.",
      scatter: "Massiver Random-Scatter fÃ¼r totale ZerstÃ¶rung.",
      sonar: "Periodische Wellenfronten wie Sonar-Pings.",
      filament: "Ruppige FÃ¤den ziehen sich durch die Glyphen.",
      ribbons: "Breite WellenbÃ¤nder umschlingen die Glyphen.",
      perlinflow: "LÃ¤sst alles einem Perlin-Flowfield folgen.",
      nebula: "Mehrschichtige Noise-Wolken reiÃŸen die Glyphen auseinander.",
      psycho: "Ultrahohe Sinus-Frequenzen biegen die Linien psychotisch.",
      wormhole: "Ein Strudel mit radialem Zug verschluckt jeden Buchstaben.",
      entropy: "Zerlegt Buchstaben zufÃ¤llig in Partikel und schrumpft sie ein.",
      liquid: "FlÃ¼ssige Scherwellen lassen die Linien wie Wasser flieÃŸen.",
      fractal: "Iterative Noise-Fraktale zerbrechen die Glyphen in komplexe Muster.",
      tsunami: "Massive horizontale Wogen Ã¼berschwemmen den Buchstaben.",
      circuit: "Rastert die Form in harte, elektronische Leiterbahnen.",
      ghost: "Mehrfach versetzte Schatten erzeugen eine spirituelle Aura.",
      blaze: "HeiÃŸe Flammen ziehen den Buchstaben nach oben.",
      shatter: "Schneidet harte Splitter in zufÃ¤llige Richtungen ein.",
      orbital: "Verlegt Punkte auf elliptische Umlaufbahnen.",
      lattice: "Zwingt Glyphen in ein versetztes Wabengitter.",
      crush: "Presst alle Striche zur Mitte und knickt sie ungleichmÃ¤ÃŸig.",
      spectrum: "Verteilt Linien in alternierende Streifen Ã¤hnlich einem Scanner.",
      helix: "Verdreht Buchstaben in schraubenartigen Bahnen.",
      eruption: "SchieÃŸt alles vertikal nach oben wie eine Explosion.",
      gridlock: "Quantisiert die Glyphen hart auf ein Block-Raster.",
      anomaly: "Bricht Linien entlang von Perlin-Anomalien auf.",
      splinter: "Erzeugt scharfkantige Splitter quer zur ursprÃ¼nglichen Kontur.",
      flux: "Zieht alles durch ein chaotisches Vektorfeld.",
      detonate: "ZerreiÃŸt Glyphen in radiale TrÃ¼mmer."
    };

    const glyphs = [];
    const history = [];
    let historyIndex = -1;
    const ui = {};
    let canvas, ctx;
    let dragMode = null;
    let activeHandle = null;
    let dragStart = null;
    let selectedGlyph = null;
    const brandFonts = ["AkUltra", "FckUltra", "NoiseUltra", "RbUltra", "TSUUltra", "VvUltra", "EchoUltra", "SliceUltra", "DRNUltra", "INKUltra", "KIDUltra", "LLOUltra", "BlockUltra", "SonarUltra"];

    /* --- Utils --- */
    const lineHeightFactor = () => state.lineHeight / 100;
    const log = (...a) => console.log("[TypoLab]", ...a);
    const deepCopyGlyphs = () => JSON.parse(JSON.stringify(glyphs));
    const normalizeFontMetrics = (font) => {
      if (!font) return;
      const upm = Number.isFinite(font.unitsPerEm) && font.unitsPerEm > 0 ? font.unitsPerEm : 1000;
      font.unitsPerEm = upm;
      if (!Number.isFinite(font.ascender)) font.ascender = Math.round(upm * 0.8);
      if (!Number.isFinite(font.descender)) font.descender = Math.round(-upm * 0.2);
    };
    const setRangeValue = (id, value) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.value = value;
      const v = document.getElementById(id + "Val");
      if (v) v.textContent = value;
    };
    const getSampleSpacing = () => {
      const base = Math.max(1.2, Math.min(8, 180 / (state.size || 1)));
      const detail = Math.max(40, Math.min(200, state.sampleDetail || 100));
      return Math.max(0.6, Math.min(12, base * (100 / detail)));
    };
    const getSamplingLimits = () => {
      const detail = Math.max(40, Math.min(200, state.sampleDetail || 100));
      const scale = detail / 100;
      return {
        maxCurveSteps: Math.round(60 + 140 * scale),
        maxPoints: Math.round(1600 * scale),
        maxExportPoints: Math.round(2200 * scale),
        maxPolylinePoints: Math.round(900 * scale)
      };
    };
    const getCanvasSize = () => {
      if (!canvas) return { width: 0, height: 0 };
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const width = rect.width || (canvas.width / ratio);
      const height = rect.height || (canvas.height / ratio);
      return { width, height };
    };
    const randomRange = (min, max) => {
      if (window.gsap?.utils?.random) return window.gsap.utils.random(min, max, true);
      return Math.random() * (max - min) + min;
    };
    let noiseSource = null;
    let renderScheduled = false;
    function initNoiseSource() {
      if (typeof p5 === "undefined" || noiseSource) return;
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.width = "1px";
      holder.style.height = "1px";
      holder.style.overflow = "hidden";
      holder.style.pointerEvents = "none";
      holder.style.opacity = "0";
      document.body.appendChild(holder);
      noiseSource = new p5(p => {
        p.setup = () => { p.noCanvas(); };
      }, holder);
    }
    const pseudoNoise = (x, y, z = 0) => {
      const s = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719) * 43758.5453;
      return s - Math.floor(s);
    };
    const sampleNoise = (x, y, z = 0) => {
      if (noiseSource?.noise) return noiseSource.noise(x, y, z);
      return pseudoNoise(x, y, z);
    };
    function scheduleRender() {
      if (renderScheduled) return;
      renderScheduled = true;
      requestAnimationFrame(() => {
        renderScheduled = false;
        renderAll();
      });
    }
    function countSegmentPoints(segs) {
      let count = 0;
      for (const s of segs) {
        if (s && s.x !== undefined && s.y !== undefined) count++;
      }
      return count;
    }
    function decimateSegments(segs, maxPoints) {
      const total = countSegmentPoints(segs);
      if (total <= maxPoints) return segs;
      const stride = Math.max(2, Math.ceil(total / maxPoints));
      const out = [];
      let count = 0;
      let keptSinceMove = 0;
      for (const s of segs) {
        if (!s) continue;
        if (s.type === "M") {
          out.push(s);
          keptSinceMove = 0;
          continue;
        }
        if (s.x === undefined || s.y === undefined) {
          out.push(s);
          keptSinceMove = 0;
          continue;
        }
        count++;
        if (keptSinceMove === 0 || count % stride === 0) {
          out.push(s);
          keptSinceMove++;
        }
      }
      return out;
    }
    function simplifySegments(segs, minDist, maxPoints) {
      if (!segs || !segs.length) return [];
      const out = [];
      let last = null;
      for (const s of segs) {
        if (!s) continue;
        if (s.type === "M") {
          out.push(s);
          last = { x: s.x, y: s.y };
          continue;
        }
        if (s.x === undefined || s.y === undefined) {
          out.push(s);
          last = null;
          continue;
        }
        if (!last || Math.hypot(s.x - last.x, s.y - last.y) >= minDist) {
          out.push(s);
          last = { x: s.x, y: s.y };
        }
      }
      if (maxPoints && countSegmentPoints(out) > maxPoints) {
        return decimateSegments(out, maxPoints);
      }
      return out;
    }
    function simplifyPolyline(points, minDist, maxPoints) {
      if (!points || points.length < 3) return points || [];
      const out = [points[0]];
      let last = points[0];
      for (let i = 1; i < points.length - 1; i++) {
        const p = points[i];
        if (Math.hypot(p.x - last.x, p.y - last.y) >= minDist) {
          out.push(p);
          last = p;
        }
      }
      out.push(points[points.length - 1]);
      if (maxPoints && out.length > maxPoints) {
        const stride = Math.max(2, Math.ceil(out.length / maxPoints));
        const trimmed = [];
        for (let i = 0; i < out.length; i += stride) trimmed.push(out[i]);
        const lastPoint = out[out.length - 1];
        if (trimmed[trimmed.length - 1] !== lastPoint) trimmed.push(lastPoint);
        return trimmed;
      }
      return out;
    }
    function rebuildAndRenderSafe() {
      try {
        buildFromText();
        renderAll();
        saveHistory();
        return true;
      } catch (err) {
        console.error(err);
        return false;
      }
    }
    function rebuildWithAutoDetail() {
      let detail = Math.max(40, Math.min(200, state.sampleDetail || 100));
      for (let i = 0; i < 4; i++) {
        if (rebuildAndRenderSafe()) return true;
        detail = Math.max(40, Math.round(detail * 0.7));
        if (detail === state.sampleDetail) break;
        state.sampleDetail = detail;
        setRangeValue("sampleDetail", detail);
      }
      return false;
    }
    function buildAlphabetSafe() {
      try {
        buildAlphabetFromTemplate();
        renderAll();
        saveHistory();
        return true;
      } catch (err) {
        console.error(err);
        return false;
      }
    }
    function buildAlphabetWithAutoDetail() {
      let detail = Math.max(40, Math.min(200, state.sampleDetail || 100));
      for (let i = 0; i < 4; i++) {
        if (buildAlphabetSafe()) return true;
        detail = Math.max(40, Math.round(detail * 0.7));
        if (detail === state.sampleDetail) break;
        state.sampleDetail = detail;
        setRangeValue("sampleDetail", detail);
      }
      return false;
    }

    /* --- DOM Ready --- */
    document.addEventListener("DOMContentLoaded", () => {
      canvas = document.getElementById("canvas2d");
      ctx = canvas.getContext("2d");
      initNoiseSource();
      setupCanvas();
      bindUI();
      buildFromText();
      renderAll();
      window.addEventListener("resize", () => { setupCanvas(); renderAll(); });
      bindCanvasInteraction();
      startBrandFontCycle();
    });

    /* --- UI Binding --- */
    function link(id, key, isCheckbox = false) {
      const el = document.getElementById(id);
      ui[id] = el;
      const sync = () => {
        const val = isCheckbox ? el.checked : (el.type === "range" ? parseFloat(el.value) : el.value);
        state[key] = val;
        const v = document.getElementById(id + "Val");
        if (v) v.textContent = isNaN(val) ? val : val;
      };
      el.addEventListener("input", sync);
      el.addEventListener("change", sync);
      sync();
    }

    function bindUI() {
      link("inputText", "text");
      link("size", "size");
      link("strokeScale", "strokeScale");
      link("tracking", "tracking");
      link("lineHeight", "lineHeight");
      link("sampleDetail", "sampleDetail");
      link("distortionType", "distortionType");
      link("distortionAmount", "distortionAmount");
      link("roughenEnabled", "roughenEnabled", true);
      link("roughness", "roughness");
      link("geometryBreak", "geometryBreak");
      link("destruction", "destruction");

      const effectInfo = document.getElementById("effectInfo");
      const updateEffectInfo = () => {
        if (!effectInfo) return;
        effectInfo.textContent = effectDescriptions[state.distortionType] || "Experimenteller Effekt.";
      };
      const distortionSelect = document.getElementById("distortionType");
      ["input", "change"].forEach(evt => distortionSelect.addEventListener(evt, updateEffectInfo));
      updateEffectInfo();

      document.getElementById("fontFile").addEventListener("change", handleFontUpload);
      document.getElementById("renderBtn").addEventListener("click", () => {
        const ok = rebuildWithAutoDetail();
        if (!ok) alert("Rendering fehlgeschlagen. Tipp: Sampling reduzieren.");
      });
      document.getElementById("alphabetBtn").addEventListener("click", () => {
        const ok = buildAlphabetWithAutoDetail();
        if (!ok) alert("Rendering fehlgeschlagen. Tipp: Sampling reduzieren.");
      });


      document.getElementById("undoBtn").addEventListener("click", undo);
      document.getElementById("redoBtn").addEventListener("click", redo);
      document.addEventListener("keydown", (e) => { if (e.ctrlKey && e.key.toLowerCase() === "z") { e.preventDefault(); undo(); } if (e.ctrlKey && e.key.toLowerCase() === "y") { e.preventDefault(); redo(); } });

      document.getElementById("exportProject").addEventListener("click", exportProject);
      document.getElementById("importProjectBtn").addEventListener("click", () => document.getElementById("projectFile").click());
      document.getElementById("projectFile").addEventListener("change", importProject);
      document.getElementById("downloadGlyphs").addEventListener("click", downloadGlyphImage);
      document.getElementById("exportFontBtn").addEventListener("click", exportAlphabetFont);
    }

    /* --- Canvas setup --- */
    function setupCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * ratio;
      canvas.height = rect.height * ratio;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }

    /* --- Font handling --- */
    function handleFontUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const ext = file.name.toLowerCase().split(".").pop();

      // SVG fonts bleiben wie bisher
      if (ext === "svg") {
        const reader = new FileReader();
        reader.onload = ev => {
          const parsed = parseSvgFont(ev.target.result);
          if (!parsed) return alert("SVG-Font konnte nicht gelesen werden.");
          state.svgFont = parsed;
          state.font = null;
          state.customFontFamily = null;
          buildFromText(); renderAll(); saveHistory();
        };
        reader.readAsText(file);
        return;
      }


      // TTF/OTF: OpenType.js mit sehr niedrigem Sampling
      const reader = new FileReader();
      reader.onload = ev => {
        let font = null;
        try {
          font = opentype.parse(ev.target.result);
          if (!font) throw new Error("Font parsing returned null");
          if (!font.glyphs || typeof font.charToGlyph !== 'function') {
            throw new Error("UngÃ¼ltige Font-Struktur");
          }
        } catch (err) {
          console.error("Font-Upload-Fehler:", err);
          alert("Font konnte nicht geladen werden: " + (err.message || "Unbekannter Fehler"));
          return;
        }

        try {
          normalizeFontMetrics(font);
          log("Font geladen:", font.names?.fullName?.en || file.name,
            "UPM:", font.unitsPerEm, "Glyphs:", font.glyphs?.length || "?");
        } catch (err) {
          console.error("Font-Metrik-Fehler:", err);
          alert("Font-Metriken konnten nicht normalisiert werden.");
          return;
        }

        state.font = font;
        state.svgFont = null;
        state.customFontFamily = null;

        // Automatische Sampling-Erkennung basierend auf Font-KomplexitÃ¤t
        const autoSampling = detectOptimalSampling(font, state.text || "TYPO LAB");
        state.sampleDetail = autoSampling;
        document.getElementById("sampleDetail").value = autoSampling;
        document.getElementById("sampleDetailVal").textContent = autoSampling.toString();

        log("Font geladen mit Auto-Sampling:", autoSampling + "%");

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try {
              buildFromText();
              renderAll();
              saveHistory();
              log("Font erfolgreich gerendert");
            } catch (err) {
              console.error("Rendering-Fehler:", err);
              // Versuche mit noch niedrigerem Sampling
              state.sampleDetail = Math.max(10, autoSampling * 0.5);
              try {
                buildFromText();
                renderAll();
                saveHistory();
                log("Font gerendert mit reduziertem Sampling:", state.sampleDetail + "%");
              } catch (err2) {
                console.error("Font zu komplex, auch mit reduziertem Sampling:", err2);
                log("âœ— Font konnte nicht automatisch gerendert werden");
                log("â†’ Verwende 'Rendern' Button fÃ¼r manuelles Rendering");
              }
            }
          });
        });
      };
      reader.readAsArrayBuffer(file);
    }

    // Automatische Sampling-Erkennung
    function detectOptimalSampling(font, text) {
      try {
        const glyphCount = font.glyphs?.length || 0;
        const textLength = text.length;

        // Analysiere durchschnittliche Glyph-KomplexitÃ¤t
        let totalComplexity = 0;
        let sampledGlyphs = 0;
        const maxSamples = Math.min(20, textLength);

        for (let i = 0; i < maxSamples && i < text.length; i++) {
          const ch = text[i];
          const glyph = font.charToGlyph(ch);
          if (glyph && glyph.path && glyph.path.commands) {
            totalComplexity += glyph.path.commands.length;
            sampledGlyphs++;
          }
        }

        const avgComplexity = sampledGlyphs > 0 ? totalComplexity / sampledGlyphs : 50;

        // Berechne optimales Sampling
        let sampling = 100;

        // Basis-Reduktion nach Glyph-Anzahl
        if (glyphCount > 2000) sampling = 15;
        else if (glyphCount > 1000) sampling = 25;
        else if (glyphCount > 500) sampling = 35;
        else if (glyphCount > 200) sampling = 50;

        // Weitere Reduktion nach KomplexitÃ¤t
        if (avgComplexity > 100) sampling *= 0.5;
        else if (avgComplexity > 50) sampling *= 0.7;
        else if (avgComplexity > 30) sampling *= 0.85;

        // Weitere Reduktion nach Text-LÃ¤nge
        if (textLength > 50) sampling *= 0.7;
        else if (textLength > 20) sampling *= 0.85;

        // Mindestens 10%, maximal 100%
        sampling = Math.max(10, Math.min(100, Math.round(sampling)));

        log("Auto-Sampling-Analyse:", {
          glyphCount,
          avgComplexity: avgComplexity.toFixed(1),
          textLength,
          resultSampling: sampling + "%"
        });

        return sampling;
      } catch (err) {
        console.error("Fehler bei Auto-Sampling-Erkennung:", err);
        return 30; // Sicherer Fallback
      }
    }

    function parseSvgFont(text) {
      try {
        const doc = new DOMParser().parseFromString(text, "image/svg+xml");
        const fontEl = doc.querySelector("font");
        const face = doc.querySelector("font-face");
        if (!fontEl || !face) return null;
        const unitsPerEm = parseFloat(face.getAttribute("units-per-em")) || 1000;
        const defaultAdv = parseFloat(fontEl.getAttribute("horiz-adv-x")) || 1000;
        const glyphsMap = {};
        doc.querySelectorAll("glyph").forEach(g => {
          const uni = g.getAttribute("unicode"); const d = g.getAttribute("d");
          if (!uni || !d) return;
          glyphsMap[uni] = { d, advanceWidth: parseFloat(g.getAttribute("horiz-adv-x")) || defaultAdv };
        });
        return { glyphs: glyphsMap, unitsPerEm, defaultAdv };
      } catch (e) { console.error(e); return null; }
    }

    /* --- Glyph building --- */
    function getAdvanceWidthCanvas(ch) {
      if (state.font) {
        try {
          const g = state.font.charToGlyph(ch);
          const upm = Number.isFinite(state.font.unitsPerEm) && state.font.unitsPerEm > 0 ? state.font.unitsPerEm : 1000;
          if (g && g.advanceWidth) return g.advanceWidth * (state.size / upm);
        } catch (e) { /* ignore */ }
      }
      if (state.svgFont) {
        const info = state.svgFont.glyphs[ch];
        const adv = info?.advanceWidth ?? state.svgFont.defaultAdv;
        return adv * (state.size / state.svgFont.unitsPerEm);
      }
      return state.size * 0.6;
    }

    function buildFromText() {
      glyphs.length = 0;
      const text = state.text || "";
      let xCursor = 0;
      let yCursor = state.size;
      const lines = text.split("\n");
      lines.forEach((line, lineIdx) => {
        xCursor = 0;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];

          // Verwende OpenType.js oder SVG
          const segs = state.font ? buildSegmentsFromOpenType(ch, xCursor, yCursor) : state.svgFont ? buildSegmentsFromSvg(ch, xCursor, yCursor) : [];


          const adv = getAdvanceWidthCanvas(ch);
          const glyph = new GlyphInstance(
            crypto.randomUUID(),
            ch,
            segs,
            { x: xCursor, y: yCursor, scaleX: 1, scaleY: 1, rotation: 0 },
            { strokeWidth: state.size * 0.05 * state.strokeScale, strokeColor: state.colorPrimary },
            { distortionType: "none", distortionAmount: 0, roughenAmount: 0 }
          );
          glyphs.push(glyph);
          xCursor += adv + state.tracking;
        }
        yCursor += state.size * lineHeightFactor();
      });
      centerGlyphsOnCanvas();
      selectGlyph(glyphs[0] || null);
      refreshGlyphList();
      saveHistory();
    }

    function getStyleTemplate() {
      if (selectedGlyph) {
        return {
          transform: {
            scaleX: selectedGlyph.transform.scaleX,
            scaleY: selectedGlyph.transform.scaleY,
            rotation: selectedGlyph.transform.rotation
          },
          style: { ...selectedGlyph.style },
          effects: { ...selectedGlyph.effects }
        };
      }
      return {
        transform: { scaleX: 1, scaleY: 1, rotation: 0 },
        style: { strokeWidth: state.size * 0.05 * state.strokeScale, strokeColor: state.colorPrimary },
        effects: { distortionType: "none", distortionAmount: 0, roughenAmount: 0 }
      };
    }

    function applyTemplateToGlyph(glyph, template) {
      glyph.transform.scaleX = template.transform.scaleX;
      glyph.transform.scaleY = template.transform.scaleY;
      glyph.transform.rotation = template.transform.rotation;
      glyph.style = JSON.parse(JSON.stringify(template.style));
      glyph.effects = JSON.parse(JSON.stringify(template.effects));
    }

    function buildAlphabetFromTemplate() {
      if (!state.font && !state.svgFont) {
        alert("Bitte zuerst einen Font laden.");
        return;
      }
      const template = getStyleTemplate();
      glyphs.length = 0;
      const baseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      const primary = ((state.text || "").trim().charAt(0) || "").toUpperCase();
      const ordered = primary && baseLetters.includes(primary)
        ? [primary, ...baseLetters.filter(ch => ch !== primary)]
        : baseLetters;
      let xCursor = 0;
      let yCursor = state.size;
      for (let i = 0; i < ordered.length; i++) {
        const ch = ordered[i];
        const segs = state.font ? buildSegmentsFromOpenType(ch, xCursor, yCursor) : state.svgFont ? buildSegmentsFromSvg(ch, xCursor, yCursor) : [];
        const adv = getAdvanceWidthCanvas(ch);
        const glyph = new GlyphInstance(
          crypto.randomUUID(),
          ch,
          segs,
          { x: xCursor, y: yCursor, scaleX: 1, scaleY: 1, rotation: 0 },
          { strokeWidth: state.size * 0.05 * state.strokeScale, strokeColor: state.colorPrimary },
          { distortionType: "none", distortionAmount: 0, roughenAmount: 0 }
        );
        applyTemplateToGlyph(glyph, template);
        glyphs.push(glyph);
        xCursor += adv + state.tracking;
      }
      centerGlyphsOnCanvas();
      selectGlyph(glyphs[0] || null);
      refreshGlyphList();
      saveHistory();
    }

    // OpenType Path Sampling mit Error-Handling
    function sampleOpenTypePath(path) {
      try {
        const segments = [];
        const commands = path.commands;
        if (!commands || commands.length === 0) return [];

        const samplingFactor = Math.max(3, Math.floor((state.sampleDetail || 50) / 10));

        for (let i = 0; i < commands.length; i++) {
          const cmd = commands[i];

          if (cmd.type === 'M') {
            segments.push({ type: 'M', x: cmd.x, y: cmd.y });
          } else if (cmd.type === 'L') {
            segments.push({ type: 'L', x: cmd.x, y: cmd.y });
          } else if (cmd.type === 'Q') {
            // Quadratic Bezier
            const prev = segments[segments.length - 1];
            if (prev && Number.isFinite(cmd.x) && Number.isFinite(cmd.y) && Number.isFinite(cmd.x1) && Number.isFinite(cmd.y1)) {
              for (let t = 1; t <= samplingFactor; t++) {
                const ratio = t / samplingFactor;
                const mt = 1 - ratio;
                const x = mt * mt * prev.x + 2 * mt * ratio * cmd.x1 + ratio * ratio * cmd.x;
                const y = mt * mt * prev.y + 2 * mt * ratio * cmd.y1 + ratio * ratio * cmd.y;
                if (Number.isFinite(x) && Number.isFinite(y)) {
                  segments.push({ type: 'L', x, y });
                }
              }
            }
          } else if (cmd.type === 'C') {
            // Cubic Bezier
            const prev = segments[segments.length - 1];
            if (prev && Number.isFinite(cmd.x) && Number.isFinite(cmd.y) && Number.isFinite(cmd.x1) && Number.isFinite(cmd.y1) && Number.isFinite(cmd.x2) && Number.isFinite(cmd.y2)) {
              for (let t = 1; t <= samplingFactor; t++) {
                const ratio = t / samplingFactor;
                const mt = 1 - ratio;
                const x = mt * mt * mt * prev.x + 3 * mt * mt * ratio * cmd.x1 + 3 * mt * ratio * ratio * cmd.x2 + ratio * ratio * ratio * cmd.x;
                const y = mt * mt * mt * prev.y + 3 * mt * mt * ratio * cmd.y1 + 3 * mt * ratio * ratio * cmd.y2 + ratio * ratio * ratio * cmd.y;
                if (Number.isFinite(x) && Number.isFinite(y)) {
                  segments.push({ type: 'L', x, y });
                }
              }
            }
          }
        }

        return segments;
      } catch (err) {
        console.error("sampleOpenTypePath Fehler:", err);
        return [];
      }
    }

    function buildSegmentsFromOpenType(ch, dx, dy) {
      try {
        if (!Number.isFinite(dx) || !Number.isFinite(dy)) return [];
        const glyph = state.font.charToGlyph(ch);
        if (!glyph) {
          log("Warnung: Glyph nicht gefunden fÃ¼r '", ch, "'");
          return [];
        }
        const path = glyph.getPath(dx, dy, state.size);
        if (!path || !path.commands || path.commands.length === 0) {
          return [];
        }
        return sampleOpenTypePath(path);
      } catch (e) {
        console.error("Fehler beim Glyph-Building fÃ¼r '", ch, "':", e);
        return [];
      }
    }

    // Neue canvas-basierte Methode fÃ¼r TTF/OTF Fonts
    function buildSegmentsFromCanvas(ch, dx, dy) {
      if (!state.customFontFamily) return [];

      try {
        // TemporÃ¤res Canvas erstellen
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // Canvas-GrÃ¶ÃŸe basierend auf SchriftgrÃ¶ÃŸe
        const size = state.size;
        const padding = size * 0.3;
        tempCanvas.width = size * 1.5;
        tempCanvas.height = size * 1.5;

        // Font rendern
        tempCtx.font = `${size}px "${state.customFontFamily}"`;
        tempCtx.fillStyle = 'black';
        tempCtx.textBaseline = 'top';
        tempCtx.fillText(ch, padding, padding);

        // Pixel-Daten extrahieren
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

        // Konturen aus Pixeln extrahieren
        const segments = extractContoursFromPixels(imageData, dx - padding, dy - padding);

        return segments;
      } catch (e) {
        console.error("Fehler beim Canvas-Glyph-Building fÃ¼r '", ch, "':", e);
        return [];
      }
    }

    // Kontur-Extraktion aus Pixeln
    function extractContoursFromPixels(imageData, offsetX, offsetY) {
      const width = imageData.width;
      const height = imageData.height;
      const data = imageData.data;
      const segments = [];

      // Sampling-Parameter
      const threshold = 128;
      const detail = Math.max(40, Math.min(200, state.sampleDetail || 100));
      const step = Math.max(1, Math.floor(8 / (detail / 100)));

      let lastX = null;
      let lastY = null;
      let inShape = false;

      // Zeilen-basiertes Scannen
      for (let y = 0; y < height; y += step) {
        for (let x = 0; x < width; x += step) {
          const idx = (y * width + x) * 4;
          const alpha = data[idx + 3];

          if (alpha > threshold) {
            const px = offsetX + x;
            const py = offsetY + y;

            if (!inShape) {
              // Neue Kontur beginnen
              segments.push({ type: 'M', x: px, y: py });
              inShape = true;
            } else {
              // Punkt zur Kontur hinzufÃ¼gen
              segments.push({ type: 'L', x: px, y: py });
            }

            lastX = px;
            lastY = py;
          } else if (inShape) {
            // Kontur beenden
            inShape = false;
          }
        }
        // Zeile beendet
        if (inShape) {
          inShape = false;
        }
      }

      return segments;
    }

    function buildSegmentsFromSvg(ch, dx, dy) {
      const g = state.svgFont.glyphs[ch];
      if (!g) return [];
      const scale = state.size / state.svgFont.unitsPerEm;
      return sampleSvgPath(g.d, scale, dx, dy);
    }

    function centerGlyphsOnCanvas() {
      if (!glyphs.length || !canvas) return;
      const bounds = getSceneBounds();
      if (!bounds) return;
      const { width, height } = getCanvasSize();
      if (!width || !height) return;
      const targetX = width / 2;
      const targetY = height / 2;
      const currentX = (bounds.minX + bounds.maxX) / 2;
      const currentY = (bounds.minY + bounds.maxY) / 2;
      const offsetX = targetX - currentX;
      const offsetY = targetY - currentY;
      if (Math.abs(offsetX) < 0.01 && Math.abs(offsetY) < 0.01) return;
      glyphs.forEach(g => shiftGlyphGeometry(g, offsetX, offsetY));
    }

    function shiftGlyphGeometry(g, dx, dy) {
      g.transform.x += dx;
      g.transform.y += dy;
      g.segments.forEach(seg => {
        ["x", "x1", "x2"].forEach(key => {
          if (seg[key] !== undefined) seg[key] += dx;
        });
        ["y", "y1", "y2"].forEach(key => {
          if (seg[key] !== undefined) seg[key] += dy;
        });
      });
    }

    function getSceneBounds() {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      glyphs.forEach(g => {
        const b = g.renderBounds || getGlyphBounds(g, getRenderedSegments(g));
        if (!b) return;
        if (b.minX < minX) minX = b.minX;
        if (b.maxX > maxX) maxX = b.maxX;
        if (b.minY < minY) minY = b.minY;
        if (b.maxY > maxY) maxY = b.maxY;
      });
      if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) return null;
      return { minX, maxX, minY, maxY };
    }

    function sampleSvgPath(d, scale, dx, dy) {
      const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
      pathEl.setAttribute("d", d);
      const len = pathEl.getTotalLength();
      const scaledLen = len * scale;
      const spacing = getSampleSpacing();
      const limits = getSamplingLimits();
      const maxSteps = Math.max(120, Math.round(limits.maxCurveSteps * 10));
      const steps = Math.min(maxSteps, Math.max(60, Math.ceil(scaledLen / spacing)));
      const segs = [];
      let prev = null;
      const jumpLimit = Math.max(4, scale * 80, spacing * 6);
      for (let i = 0; i <= steps; i++) {
        const p = pathEl.getPointAtLength((len * i) / steps);
        const x = p.x * scale + dx;
        const y = -p.y * scale + dy;
        if (!prev || Math.hypot(x - prev.x, y - prev.y) > jumpLimit) {
          segs.push({ type: "M", x, y });
        } else {
          if (Math.abs(x - prev.x) < 0.01 && Math.abs(y - prev.y) < 0.01) continue;
          segs.push({ type: "L", x, y });
        }
        prev = { x, y };
      }
      const minDist = Math.max(0.4, spacing * 0.6);
      return simplifySegments(segs, minDist, limits.maxPoints);
    }

    /* --- Adaptive BÃ©zier Sampling Helpers --- */
    function calculateQuadraticBezierLength(p0, p1, p2) {
      // Approximation using chord length
      const chord = Math.hypot(p2.x - p0.x, p2.y - p0.y);
      const controlNet = Math.hypot(p1.x - p0.x, p1.y - p0.y) + Math.hypot(p2.x - p1.x, p2.y - p1.y);
      return (chord + controlNet) / 2;
    }

    function calculateCubicBezierLength(p0, p1, p2, p3) {
      // Approximation using chord and control polygon
      const chord = Math.hypot(p3.x - p0.x, p3.y - p0.y);
      const controlNet = Math.hypot(p1.x - p0.x, p1.y - p0.y) +
        Math.hypot(p2.x - p1.x, p2.y - p1.y) +
        Math.hypot(p3.x - p2.x, p3.y - p2.y);
      return (2 * chord + controlNet) / 3;
    }

    function adaptiveQuadraticSample(p0, p1, p2, spacing, maxSteps) {
      const length = calculateQuadraticBezierLength(p0, p1, p2);
      const steps = Math.min(maxSteps, Math.max(3, Math.ceil(length / spacing)));
      const points = [];
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const inv = 1 - t;
        points.push({
          x: inv * inv * p0.x + 2 * inv * t * p1.x + t * t * p2.x,
          y: inv * inv * p0.y + 2 * inv * t * p1.y + t * t * p2.y
        });
      }
      return points;
    }

    function adaptiveCubicSample(p0, p1, p2, p3, spacing, maxSteps) {
      const length = calculateCubicBezierLength(p0, p1, p2, p3);
      const steps = Math.min(maxSteps, Math.max(4, Math.ceil(length / spacing)));
      const points = [];
      for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const inv = 1 - t;
        points.push({
          x: inv * inv * inv * p0.x + 3 * inv * inv * t * p1.x + 3 * inv * t * t * p2.x + t * t * t * p3.x,
          y: inv * inv * inv * p0.y + 3 * inv * inv * t * p1.y + 3 * inv * t * t * p2.y + t * t * t * p3.y
        });
      }
      return points;
    }

    function sampleOpenTypePath(path) {
      if (!path || !path.commands) return [];
      const spacing = getSampleSpacing();
      const limits = getSamplingLimits();
      const minStep = Math.max(0.8, spacing * 0.7); // Increased from 0.2 to reduce redundant points
      const segs = [];
      let pen = { x: 0, y: 0 };
      let start = null;
      let lastAdded = null;

      // Improved addPoint with angle-based filtering
      const addPoint = (x, y, isCorner = false) => {
        if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
        const dx = x - pen.x;
        const dy = y - pen.y;
        const dist = Math.hypot(dx, dy);

        // Always add corners and first points
        if (isCorner || !lastAdded) {
          if (dist >= minStep * 0.5) {
            segs.push({ type: "L", x, y });
            pen = { x, y };
            lastAdded = { x, y };
            return true;
          }
          return false;
        }

        // For curve points, check both distance and angle
        if (dist < minStep) return false;

        // Check angle change to preserve important points
        if (lastAdded) {
          const dx1 = lastAdded.x - pen.x;
          const dy1 = lastAdded.y - pen.y;
          const dx2 = x - pen.x;
          const dy2 = y - pen.y;
          const angle1 = Math.atan2(dy1, dx1);
          const angle2 = Math.atan2(dy2, dx2);
          let angleDiff = Math.abs(angle2 - angle1);
          if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

          // Skip point if angle change is minimal
          if (angleDiff < 0.05 && dist < spacing * 2) return false;
        }

        segs.push({ type: "L", x, y });
        pen = { x, y };
        lastAdded = { x, y };
        return true;
      };

      // Early exit if too many points
      let pointCount = 0;
      const maxTotalPoints = limits.maxPoints * 1.5; // Allow some overhead before simplification

      path.commands.forEach(cmd => {
        if (pointCount > maxTotalPoints) return; // Skip if we've hit the limit

        if (cmd.type === "M") {
          if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) return;
          segs.push({ type: "M", x: cmd.x, y: cmd.y });
          pen = { x: cmd.x, y: cmd.y };
          start = { x: cmd.x, y: cmd.y };
          lastAdded = null;
          return;
        }
        if (cmd.type === "L") {
          if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y)) return;
          if (addPoint(cmd.x, cmd.y, true)) pointCount++;
          return;
        }
        if (cmd.type === "Q") {
          if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y) || !Number.isFinite(cmd.x1) || !Number.isFinite(cmd.y1)) return;
          const p0 = { x: pen.x, y: pen.y };
          const p1 = { x: cmd.x1, y: cmd.y1 };
          const p2 = { x: cmd.x, y: cmd.y };
          const points = adaptiveQuadraticSample(p0, p1, p2, spacing, limits.maxCurveSteps);
          points.forEach(pt => {
            if (pointCount < maxTotalPoints && addPoint(pt.x, pt.y)) pointCount++;
          });
          return;
        }
        if (cmd.type === "C") {
          if (!Number.isFinite(cmd.x) || !Number.isFinite(cmd.y) || !Number.isFinite(cmd.x1) || !Number.isFinite(cmd.y1) || !Number.isFinite(cmd.x2) || !Number.isFinite(cmd.y2)) return;
          const p0 = { x: pen.x, y: pen.y };
          const p1 = { x: cmd.x1, y: cmd.y1 };
          const p2 = { x: cmd.x2, y: cmd.y2 };
          const p3 = { x: cmd.x, y: cmd.y };
          const points = adaptiveCubicSample(p0, p1, p2, p3, spacing, limits.maxCurveSteps);
          points.forEach(pt => {
            if (pointCount < maxTotalPoints && addPoint(pt.x, pt.y)) pointCount++;
          });
          return;
        }
        if (cmd.type === "Z") {
          if (start && addPoint(start.x, start.y, true)) pointCount++;
          segs.push({ type: "Z" });
          start = null;
          return;
        }
      });

      // Only simplify if we exceeded the limit
      if (pointCount > limits.maxPoints) {
        const minDist = Math.max(0.6, spacing * 0.8);
        return simplifySegments(segs, minDist, limits.maxPoints);
      }

      return segs;
    }

    function flattenSegmentsToPolylines(segs) {
      const polylines = [];
      let current = [];
      let pen = { x: 0, y: 0 };
      const commit = () => { if (current.length > 1) polylines.push(current); current = []; };
      const ensureCurrent = () => { if (!current.length) current.push({ x: pen.x, y: pen.y }); };
      segs.forEach(cmd => {
        if (cmd.type === "M") {
          commit();
          current = [{ x: cmd.x, y: cmd.y }];
          pen = { x: cmd.x, y: cmd.y };
          return;
        }
        if (cmd.type === "L") {
          ensureCurrent();
          current.push({ x: cmd.x, y: cmd.y });
          pen = { x: cmd.x, y: cmd.y };
          return;
        }
        if (cmd.type === "Q") {
          ensureCurrent();
          const start = { x: pen.x, y: pen.y };
          const ctrl = { x: cmd.x1, y: cmd.y1 };
          const end = { x: cmd.x, y: cmd.y };
          const steps = Math.max(6, Math.floor(Math.hypot(end.x - start.x, end.y - start.y) / 8));
          for (let t = 1; t <= steps; t++) {
            const ratio = t / steps;
            const inv = 1 - ratio;
            const x = inv * inv * start.x + 2 * inv * ratio * ctrl.x + ratio * ratio * end.x;
            const y = inv * inv * start.y + 2 * inv * ratio * ctrl.y + ratio * ratio * end.y;
            current.push({ x, y });
          }
          pen = end;
          return;
        }
        if (cmd.type === "C") {
          ensureCurrent();
          const start = { x: pen.x, y: pen.y };
          const c1 = { x: cmd.x1, y: cmd.y1 };
          const c2 = { x: cmd.x2, y: cmd.y2 };
          const end = { x: cmd.x, y: cmd.y };
          const steps = Math.max(10, Math.floor(Math.hypot(end.x - start.x, end.y - start.y) / 6));
          for (let t = 1; t <= steps; t++) {
            const ratio = t / steps;
            const inv = 1 - ratio;
            const x = inv * inv * inv * start.x + 3 * inv * inv * ratio * c1.x + 3 * inv * ratio * ratio * c2.x + ratio * ratio * ratio * end.x;
            const y = inv * inv * inv * start.y + 3 * inv * inv * ratio * c1.y + 3 * inv * ratio * ratio * c2.y + ratio * ratio * ratio * end.y;
            current.push({ x, y });
          }
          pen = end;
          return;
        }
        if (cmd.type === "Z") {
          if (current.length) current.push({ ...current[0] });
          commit();
          pen = current.length ? { ...current[current.length - 1] } : pen;
        }
      });
      commit();
      return polylines;
    }

    function createStrokePolygons(points, halfWidth) {
      if (points.length < 2) return [];
      const left = [], right = [];
      for (let i = 0; i < points.length; i++) {
        const prev = points[i - 1] || points[i];
        const next = points[i + 1] || points[i];
        let dx = next.x - prev.x;
        let dy = next.y - prev.y;
        let len = Math.hypot(dx, dy);
        if (len < 0.0001) { dx = 0; dy = 1; len = 1; }
        dx /= len; dy /= len;
        const nx = -dy * halfWidth;
        const ny = dx * halfWidth;
        left.push({ x: points[i].x + nx, y: points[i].y + ny });
        right.push({ x: points[i].x - nx, y: points[i].y - ny });
      }
      const polygon = left.concat(right.reverse());
      return polygon;
    }

    /* --- Effects --- */
    function applyWave(segs, amt) {
      const freq = 0.02; return segs.map(s => s.x === undefined ? { ...s } : { ...s, y: s.y + Math.sin(s.x * freq) * amt });
    }
    function applyZigZag(segs, amt) {
      return segs.map((s, i) => s.x === undefined ? { ...s } : { ...s, y: s.y + (i % 2 === 0 ? amt : -amt) });
    }
    function applyNoise(segs, amt) {
      const rand = () => (Math.random() - 0.5) * 2 * amt;
      return segs.map(s => s.x === undefined ? { ...s } : { ...s, x: s.x + rand(), y: s.y + rand() });
    }
    function applyRoughen(segs, rough) {
      const limits = getSamplingLimits();
      if (segs.length > limits.maxPoints * 2) return segs;
      const out = [];
      for (let i = 0; i < segs.length; i++) {
        const s = segs[i]; out.push(s);
        const n = segs[i + 1]; if (!n || s.x === undefined || n.x === undefined) continue;
        const midx = (s.x + n.x) / 2 + (Math.random() - 0.5) * rough;
        const midy = (s.y + n.y) / 2 + (Math.random() - 0.5) * rough;
        out.push({ type: "L", x: midx, y: midy });
      }
      return out;
    }
    function applyTwist(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      if (!width || !height) return segs.map(s => ({ ...s }));
      const cx = width / 2, cy = height / 2;
      const maxRadius = Math.sqrt(cx * cx + cy * cy) || 1;
      const maxAngle = amt * (Math.PI / 180);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const radius = Math.sqrt(dx * dx + dy * dy);
        const t = radius / maxRadius;
        const angle = maxAngle * t;
        const cos = Math.cos(angle), sin = Math.sin(angle);
        return { ...s, x: dx * cos - dy * sin + cx, y: dx * sin + dy * cos + cy };
      });
    }
    function applyBulge(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      if (!width || !height) return segs.map(s => ({ ...s }));
      const cx = width / 2, cy = height / 2;
      const maxRadius = Math.sqrt(cx * cx + cy * cy) || 1;
      const intensity = amt / 100;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const radius = Math.sqrt(dx * dx + dy * dy);
        const factor = 1 + intensity * (1 - radius / maxRadius);
        return { ...s, x: cx + dx * factor, y: cy + dy * factor };
      });
    }
    function applyShear(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      if (!height) return segs.map(s => ({ ...s }));
      const cy = height / 2;
      const intensity = amt / 200;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        return { ...s, x: s.x + (s.y - cy) * intensity };
      });
    }
    function applyRipple(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const freq = 0.04;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const offset = Math.sin(dist * freq) * amt * 0.5;
        return { ...s, x: s.x + (dx / dist) * offset, y: s.y + (dy / dist) * offset };
      });
    }
    function applyShockwave(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy) || 1;
      const ring = maxDist * 0.6;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const t = Math.max(0, 1 - Math.abs(dist - ring) / Math.max(1, ring));
        const disp = t * t * amt;
        const norm = dist ? 1 / dist : 0;
        return { ...s, x: s.x + dx * norm * disp, y: s.y + dy * norm * disp };
      });
    }
    function applyTurbulence(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const strength = amt * 0.8;
      const scale = 0.01;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        let nx = 0, ny = 0, freq = 1, amp = 1;
        for (let i = 0; i < 3; i++) {
          const n1 = sampleNoise(s.x * scale * freq, s.y * scale * freq, i * 10);
          const n2 = sampleNoise((s.x + 400) * scale * freq, (s.y - 200) * scale * freq, i * 20);
          nx += (n1 - 0.5) * 2 * amp;
          ny += (n2 - 0.5) * 2 * amp;
          freq *= 2;
          amp *= 0.5;
        }
        return { ...s, x: s.x + nx * strength, y: s.y + ny * strength };
      });
    }
    function applyFracture(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const shardScale = Math.max(5, 80 - amt);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const id = Math.floor((s.x + s.y) / shardScale);
        const angle = pseudoNoise(id, id * 0.37) * Math.PI * 2;
        const radius = (pseudoNoise(id * 2, id * 0.11) - 0.5) * 2 * amt;
        return { ...s, x: s.x + Math.cos(angle) * radius, y: s.y + Math.sin(angle) * radius };
      });
    }
    function applyRupture(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const block = Math.max(8, 120 - amt * 0.9);
      const shift = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const bx = Math.floor(s.x / block);
        const by = Math.floor(s.y / block);
        const n1 = sampleNoise(bx * 0.7, by * 0.7);
        const n2 = sampleNoise(bx * 0.7 + 40, by * 0.7 - 80);
        return { ...s, x: s.x + (n1 - 0.5) * 2 * shift, y: s.y + (n2 - 0.5) * 2 * shift };
      });
    }
    function applyCrumble(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const drop = Math.min(0.88, amt / 120);
      const fall = amt * 0.9;
      const out = [];
      segs.forEach(cmd => {
        if (cmd.x === undefined) { out.push({ ...cmd }); return; }
        if (cmd.type !== "M") {
          const n = sampleNoise(cmd.x * 0.025, cmd.y * 0.025);
          if (n < drop && cmd.type !== "Z") return;
          const drift = (n - 0.5) * 2 * amt * 0.35;
          out.push({ ...cmd, x: cmd.x + drift, y: cmd.y + fall * (0.2 + n * 0.8) + drift * 0.25 });
          return;
        }
        out.push({ ...cmd });
      });
      return out;
    }
    function applySmear(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      if (!height) return segs.map(s => ({ ...s }));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const smearFactor = (s.y / height);
        const offset = smearFactor * amt * randomRange(-1, 1);
        const drift = Math.sin((s.x + s.y) * 0.015) * amt * 0.1;
        return { ...s, x: s.x + offset, y: s.y + drift };
      });
    }
    function applyGlitch(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      if (!height) return segs.map(s => ({ ...s }));
      const bands = 10;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const band = Math.floor((s.y / height) * bands);
        const dir = band % 2 === 0 ? 1 : -1;
        let x = s.x + dir * amt * 0.4;
        let y = s.y;
        const g = pseudoNoise(band, s.x * 0.05);
        x += (g - 0.5) * amt;
        if (g > 0.8) y += dir * amt * 0.6;
        if (g < 0.2) x -= dir * amt;
        return { ...s, x, y };
      });
    }
    function applyMelt(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      if (!width || !height) return segs.map(s => ({ ...s }));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const drip = Math.pow(s.x / width, 1.4) * amt * 0.6;
        const sag = (s.y / height) * amt * 0.4;
        const wobble = Math.sin((s.x + s.y) * 0.02) * amt * 0.2;
        return { ...s, y: s.y + drip + sag + wobble };
      });
    }
    function applyDisintegrate(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const dropChance = Math.min(0.9, amt / 120);
      const out = [];
      segs.forEach(cmd => {
        if (cmd.x === undefined) { out.push({ ...cmd }); return; }
        const n = sampleNoise(cmd.x * 0.02, cmd.y * 0.02);
        if (n < dropChance && cmd.type !== "M") return;
        const jitterX = (n - 0.5) * 2 * amt;
        const jitterY = (sampleNoise(cmd.x * 0.015 + 50, cmd.y * 0.015 - 20) - 0.5) * 2 * amt;
        out.push({ ...cmd, x: cmd.x + jitterX, y: cmd.y + jitterY });
      });
      return out;
    }
    function applyImplode(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const intensity = Math.min(0.95, amt / 120);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        return { ...s, x: cx + dx * (1 - intensity), y: cy + dy * (1 - intensity) };
      });
    }
    function applyExplode(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const boost = 1 + amt / 60;
        const chaos = randomRange(-amt * 0.2, amt * 0.2);
        return { ...s, x: cx + dx / dist * (dist * boost + chaos), y: cy + dy / dist * (dist * boost + chaos) };
      });
    }
    function applyShred(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const stripes = Math.max(2, Math.round(amt / 6));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const norm = (s.x + s.y) / Math.max(1, stripes);
        const stripe = ((Math.floor(norm) % stripes) + stripes) % stripes;
        const dir = stripe % 2 === 0 ? 1 : -1;
        const tear = dir * amt * 0.3 + randomRange(-amt * 0.2, amt * 0.2);
        return { ...s, y: s.y + tear };
      });
    }
    function applyVoid(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const holeX = width / 2 + Math.sin(amt) * 40;
      const holeY = height / 2 + Math.cos(amt * 0.5) * 20;
      const radius = Math.max(40, amt * 3);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - holeX;
        const dy = s.y - holeY;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const pull = Math.max(0, 1 - dist / radius);
        return { ...s, x: s.x - dx * pull * 0.8, y: s.y - dy * pull * 0.8 };
      });
    }
    function applyCyclone(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const strength = amt / 60;
      const radial = amt / 90;
      const maxDim = Math.max(width, height) || 1;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) + strength * (dist / maxDim);
        const radius = dist + Math.sin(dist * 0.02) * radial * (dist / maxDim);
        return { ...s, x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
      });
    }
    function applyGravityWell(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const wells = [
        { x: width * 0.25, y: height * 0.3, polarity: 1 },
        { x: width * 0.75, y: height * 0.7, polarity: -1 },
        { x: width * 0.45, y: height * 0.5, polarity: 1 }
      ];
      const intensity = Math.max(5, amt * 0.8);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        let x = s.x, y = s.y;
        wells.forEach(well => {
          const dx = well.x - x;
          const dy = well.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const pull = intensity / Math.pow(dist, 0.8);
          x += dx / dist * pull * well.polarity;
          y += dy / dist * pull * well.polarity;
        });
        return { ...s, x, y };
      });
    }
    function applyPulse(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const freq = 0.05;
      const amp = amt * 0.6;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const offset = Math.sin((s.x + s.y) * freq) * amp;
        return { ...s, x: s.x + offset, y: s.y + Math.cos((s.x - s.y) * freq) * amp * 0.5 };
      });
    }
    function applyCrystal(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const steps = Math.max(4, Math.round(amt / 4));
      const angleStep = (Math.PI * 2) / steps;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const radius = Math.sqrt(dx * dx + dy * dy);
        let angle = Math.atan2(dy, dx);
        angle = Math.round(angle / angleStep) * angleStep;
        const spike = 1 + Math.sin(angle * steps) * (amt / 150);
        return { ...s, x: cx + Math.cos(angle) * radius * spike, y: cy + Math.sin(angle) * radius * spike };
      });
    }
    function applySlipstream(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const amp = amt * 0.5;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const flow = Math.sin(s.y * 0.03) * amp + Math.cos((s.x + s.y) * 0.01) * amp * 0.3;
        const lift = Math.cos(s.x * 0.04) * amp * 0.2;
        return { ...s, x: s.x + flow, y: s.y + lift };
      });
    }
    function applyWarpField(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.008;
      const str = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const n1 = sampleNoise(s.x * scale, s.y * scale);
        const n2 = sampleNoise((s.x + 400) * scale, (s.y - 200) * scale);
        const rot = sampleNoise((s.x - 150) * scale, (s.y + 310) * scale) * Math.PI * 2;
        const dx = (n1 - 0.5) * 2 * str;
        const dy = (n2 - 0.5) * 2 * str;
        return { ...s, x: s.x + dx * Math.cos(rot) - dy * Math.sin(rot), y: s.y + dx * Math.sin(rot) + dy * Math.cos(rot) };
      });
    }
    function applySplat(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const burst = amt * 1.2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const n = sampleNoise(s.x * 0.02, s.y * 0.02);
        const angle = n * Math.PI * 8;
        const power = Math.pow(n, 2) * burst;
        return { ...s, x: s.x + Math.cos(angle) * power, y: s.y + Math.sin(angle) * power };
      });
    }
    function applyFold(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const strength = Math.min(0.95, amt / 120);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const mirrorX = cx - (s.x - cx);
        const mirrorY = cy - (s.y - cy);
        return {
          ...s,
          x: s.x * (1 - strength) + mirrorX * strength,
          y: s.y * (1 - strength * 0.6) + mirrorY * strength * 0.6
        };
      });
    }
    function applyScramble(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const seed = sampleNoise(s.x * 0.04, s.y * 0.04);
        let x = s.x, y = s.y;
        if (seed > 0.66) { const tmp = x; x = y; y = tmp; }
        const jitter = (seed - 0.5) * 2 * amt;
        x += jitter;
        y += Math.sin(seed * Math.PI * 4) * amt * 0.6;
        if (seed < 0.15) x -= amt;
        if (seed > 0.85) y += amt * 0.4;
        return { ...s, x, y };
      });
    }
    function applyStorm(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const centerX = width / 2;
      const gust = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wind = Math.sin((s.y + centerX) * 0.05) * gust;
        const swirl = Math.cos((s.x - s.y) * 0.03) * gust * 0.5;
        const chaos = (sampleNoise(s.x * 0.02, s.y * 0.02) - 0.5) * amt;
        return { ...s, x: s.x + wind + chaos, y: s.y + swirl + chaos * 0.5 };
      });
    }
    function applyQuake(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const shakeX = Math.sin(s.y * 0.3) * amt * 0.4;
        const shakeY = Math.sin(s.x * 0.25) * amt * 0.3;
        const rumble = (sampleNoise(s.x * 0.05, s.y * 0.05) - 0.5) * amt;
        return { ...s, x: s.x + shakeX + rumble, y: s.y + shakeY + rumble * 0.6 };
      });
    }
    function applyCurtain(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width } = getCanvasSize();
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const drape = (s.x / width) * amt;
        const sway = Math.sin((s.x / width) * Math.PI * 2) * amt * 0.3;
        return { ...s, x: s.x + sway, y: s.y + drape };
      });
    }
    function applyKaleido(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const slices = Math.max(3, Math.round(amt / 5));
      const sliceAngle = (Math.PI * 2) / slices;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const radius = Math.sqrt(dx * dx + dy * dy);
        let angle = Math.atan2(dy, dx) + Math.PI;
        angle = angle % (Math.PI * 2);
        let mod = angle % sliceAngle;
        if (mod > sliceAngle / 2) mod = sliceAngle - mod;
        const finalAngle = mod - sliceAngle / 4;
        return { ...s, x: cx + Math.cos(finalAngle) * radius, y: cy + Math.sin(finalAngle) * radius };
      });
    }
    function applyCluster(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const clusters = Math.max(2, Math.round(amt / 8));
      const centers = Array.from({ length: clusters }, (_, i) => ({
        x: sampleNoise(i * 7.1, amt * 0.01 + i) * width,
        y: sampleNoise(i * 3.7, amt * 0.02 - i) * height
      }));
      const pull = amt * 0.4;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const seed = sampleNoise(s.x * 0.01, s.y * 0.01);
        const idx = Math.min(clusters - 1, Math.floor(seed * clusters));
        const target = centers[idx];
        return { ...s, x: s.x + (target.x - s.x) * (pull / 100), y: s.y + (target.y - s.y) * (pull / 100) };
      });
    }
    function applyTangle(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const strength = amt * 0.6;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const noiseAngle = sampleNoise(s.x * 0.02, s.y * 0.02) * Math.PI * 4;
        const radius = (sampleNoise(s.x * 0.02 + 100, s.y * 0.02 - 50) - 0.5) * 2 * strength;
        return { ...s, x: s.x + Math.cos(noiseAngle) * radius, y: s.y + Math.sin(noiseAngle) * radius };
      });
    }
    function applyMagnetic(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const magnets = [
        { x: width * 0.15, y: height * 0.2, polarity: 1 },
        { x: width * 0.85, y: height * 0.3, polarity: -1 },
        { x: width * 0.4, y: height * 0.85, polarity: 1 }
      ];
      const power = amt * 1.1;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        let x = s.x, y = s.y;
        magnets.forEach(m => {
          const dx = m.x - x;
          const dy = m.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = power / Math.pow(dist, 0.7);
          x += dx / dist * force * m.polarity;
          y += dy / dist * force * m.polarity;
        });
        return { ...s, x, y };
      });
    }
    function applyPlasma(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const freq = 0.025;
      const amp = amt * 0.6;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wave = Math.sin(s.x * freq) + Math.cos(s.y * freq * 1.3);
        const n = sampleNoise(s.x * 0.015, s.y * 0.015);
        return { ...s, x: s.x + wave * amp * 0.5, y: s.y + (n - 0.5) * 2 * amp };
      });
    }
    function applyDust(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const dropChance = Math.min(0.95, amt / 110);
      const jitter = amt * 0.8;
      const out = [];
      segs.forEach(cmd => {
        if (cmd.x === undefined) { out.push({ ...cmd }); return; }
        const n = sampleNoise(cmd.x * 0.04, cmd.y * 0.04);
        if (n < dropChance && cmd.type !== "M") return;
        out.push({ ...cmd, x: cmd.x + (n - 0.5) * 2 * jitter, y: cmd.y + (sampleNoise(cmd.x * 0.05 + 20, cmd.y * 0.05 - 20) - 0.5) * 2 * jitter });
      });
      return out;
    }
    function applySlice(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      const bands = Math.max(2, Math.round(amt / 4));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const sliceIndex = Math.floor((s.y / Math.max(1, height)) * bands);
        const dir = sliceIndex % 2 === 0 ? 1 : -1;
        const offset = dir * amt * 0.8;
        return { ...s, x: s.x + offset };
      });
    }
    function applySwirl(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const freq = 0.006;
      const strength = amt / 30;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const theta = sampleNoise(s.x * freq, s.y * freq) * Math.PI * 4;
        const radius = (sampleNoise(s.x * freq + 100, s.y * freq - 50) - 0.5) * 2 * strength;
        return { ...s, x: s.x + Math.cos(theta) * radius * amt * 0.05, y: s.y + Math.sin(theta) * radius * amt * 0.05 };
      });
    }
    function applyInkblot(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2;
      const mirror = Math.min(1, amt / 100);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const mirroredX = cx - (s.x - cx);
        const noiseTerm = (sampleNoise(s.x * 0.02, s.y * 0.02) - 0.5) * amt;
        return {
          ...s,
          x: s.x * (1 - mirror) + mirroredX * mirror + noiseTerm * 0.4,
          y: s.y + noiseTerm * 0.2
        };
      });
    }
    function applyRadiate(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const pulse = Math.sin(dist * 0.04 + amt * 0.1) * amt;
        return { ...s, x: s.x + dx / dist * pulse, y: s.y + dy / dist * pulse };
      });
    }
    function applyScatter(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const chaos = amt * 1.2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        return {
          ...s,
          x: s.x + randomRange(-chaos, chaos),
          y: s.y + randomRange(-chaos, chaos)
        };
      });
    }
    function applySonar(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const time = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const wave = Math.sin(dist * 0.1 - time * 0.001) * amt;
        return { ...s, x: s.x + dx / dist * wave * 0.6, y: s.y + dy / dist * wave * 0.6 };
      });
    }
    function applyFilament(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.015;
      const force = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const angle = sampleNoise(s.x * scale, s.y * scale) * Math.PI * 4;
        const drift = (sampleNoise((s.x + 500) * scale, (s.y - 120) * scale) - 0.5) * force;
        return { ...s, x: s.x + Math.cos(angle) * force + drift, y: s.y + Math.sin(angle) * force + drift * 0.5 };
      });
    }
    function applyRibbons(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const freq = 0.02;
      const swing = amt * 0.7;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wave = Math.sin(s.y * freq) * swing;
        return { ...s, x: s.x + wave, y: s.y + Math.cos((s.x + s.y) * freq) * swing * 0.3 };
      });
    }
    function applyPerlinFlow(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.01;
      const strength = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const nx = sampleNoise(s.x * scale, s.y * scale);
        const ny = sampleNoise((s.x + 200) * scale, (s.y - 300) * scale);
        return { ...s, x: s.x + (nx - 0.5) * 2 * strength, y: s.y + (ny - 0.5) * 2 * strength };
      });
    }
    function applyFractal(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const baseScale = 0.02;
      const iterations = Math.max(2, Math.round(amt / 15));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        let ox = s.x, oy = s.y, freq = 1, amp = amt * 0.12;
        for (let i = 0; i < iterations; i++) {
          const nx = sampleNoise(ox * baseScale * freq, oy * baseScale * freq);
          const ny = sampleNoise((ox + 200) * baseScale * freq, (oy - 120) * baseScale * freq);
          ox += (nx - 0.5) * 2 * amp;
          oy += (ny - 0.5) * 2 * amp;
          freq *= 1.6;
          amp *= 0.65;
        }
        return { ...s, x: ox, y: oy };
      });
    }
    function applyTsunami(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      const center = height / 2;
      const freq = 0.012;
      const crest = amt * 1.2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wave = Math.sin((s.y - center) * freq) * crest;
        const surge = Math.cos(s.x * freq * 0.5) * amt * 0.3;
        return { ...s, x: s.x + wave + surge, y: s.y + Math.sin((s.y + crest) * freq) * amt * 0.2 };
      });
    }
    function applyCircuit(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const grid = Math.max(4, amt * 0.8);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const snappedX = Math.round(s.x / grid) * grid;
        const snappedY = Math.round(s.y / grid) * grid;
        const jitter = (sampleNoise(s.x * 0.03, s.y * 0.03) - 0.5) * grid * 0.6;
        return { ...s, x: snappedX + jitter, y: snappedY + Math.sin((snappedX + snappedY) * 0.02) * grid * 0.2 };
      });
    }
    function applyGhost(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const layers = Math.min(4, Math.max(2, Math.round(amt / 25)));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        let ox = s.x, oy = s.y;
        for (let i = 1; i <= layers; i++) {
          const shift = (sampleNoise((s.x + i * 50) * 0.01, (s.y - i * 30) * 0.01) - 0.5) * amt * 0.2;
          ox += shift;
          oy += Math.sin((s.x + i * 20) * 0.02) * amt * 0.05;
        }
        return { ...s, x: ox, y: oy };
      });
    }
    function applyBlaze(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { height } = getCanvasSize();
      const lift = amt * 0.8;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const flicker = (sampleNoise(s.x * 0.025, s.y * 0.025) - 0.5) * amt * 0.6;
        const taper = (1 - Math.min(1, s.y / Math.max(1, height))) * lift;
        return { ...s, x: s.x + flicker * 0.4, y: s.y - taper + flicker };
      });
    }
    function applyShatter(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const slices = Math.max(3, Math.round(amt / 10));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const band = Math.floor(((s.x + s.y) / 40) % slices);
        const dir = band % 2 === 0 ? 1 : -1;
        const shift = dir * amt * 0.5;
        const offset = (sampleNoise(s.x * 0.02, s.y * 0.02) - 0.5) * amt;
        return { ...s, x: s.x + shift + offset, y: s.y + Math.sin(band) * amt * 0.2 };
      });
    }
    function applyOrbital(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const orbit = amt / 80;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const angle = Math.atan2(dy, dx) + orbit;
        const radius = Math.sqrt(dx * dx + dy * dy);
        const e = (Math.sin(angle * 3) * 0.3 + 1);
        return { ...s, x: cx + Math.cos(angle) * radius * e, y: cy + Math.sin(angle) * (radius / e) };
      });
    }
    function applyLattice(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const grid = Math.max(5, amt * 0.6);
      const offset = grid / 2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const row = Math.floor(s.y / grid);
        const shift = row % 2 === 0 ? 0 : offset;
        const snappedX = Math.round((s.x - shift) / grid) * grid + shift;
        const snappedY = Math.round(s.y / grid) * grid;
        return { ...s, x: snappedX, y: snappedY };
      });
    }
    function applyNebula(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.008;
      const depth = amt * 1.2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const swirl = sampleNoise(s.x * scale, s.y * scale) * Math.PI * 6;
        const cloud = (sampleNoise((s.x + 250) * scale, (s.y - 400) * scale) - 0.5) * depth;
        return {
          ...s,
          x: s.x + Math.cos(swirl) * depth * 0.4 + cloud,
          y: s.y + Math.sin(swirl) * depth * 0.4 + cloud * 0.5
        };
      });
    }
    function applyPsycho(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const freq = 0.09;
      const amp = amt * 0.8;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const warpX = Math.sin(s.x * freq) + Math.cos(s.y * freq * 1.7);
        const warpY = Math.sin((s.x + s.y) * freq * 1.2) - Math.cos(s.x * freq * 2.1);
        return { ...s, x: s.x + warpX * amp, y: s.y + warpY * amp };
      });
    }
    function applyWormhole(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      const twist = amt / 20;
      const pull = Math.min(0.95, amt / 140);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const angle = Math.atan2(dy, dx) + twist * (dist / Math.max(width, height));
        const radius = dist * (1 - pull) - Math.sin(dist * 0.05) * amt * 0.3;
        return { ...s, x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
      });
    }
    function applyEntropy(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const drop = Math.min(0.85, amt / 120);
      const shrink = 1 - Math.min(0.8, amt / 200);
      const out = [];
      segs.forEach(cmd => {
        if (cmd.x === undefined) { out.push({ ...cmd }); return; }
        if (Math.random() < drop && cmd.type !== "M") return;
        const fuzz = (sampleNoise(cmd.x * 0.03, cmd.y * 0.03) - 0.5) * amt * 1.2;
        out.push({ ...cmd, x: cmd.x * shrink + fuzz, y: cmd.y * shrink + fuzz * 0.6 });
      });
      return out;
    }
    function applyLiquid(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const freq = 0.02;
      const flow = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wave = Math.sin(s.y * freq) * flow;
        const ripple = Math.cos((s.x + s.y) * freq * 0.7) * flow * 0.5;
        return { ...s, x: s.x + wave, y: s.y + ripple };
      });
    }
    function applyCrush(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width } = getCanvasSize();
      const cx = width / 2;
      const squeeze = Math.max(0.1, 1 - amt / 120);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const offset = (sampleNoise(s.x * 0.02, s.y * 0.02) - 0.5) * amt * 0.2;
        return { ...s, x: cx + dx * squeeze + offset, y: s.y + offset * 0.5 };
      });
    }
    function applySpectrum(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const bands = Math.max(3, Math.round(amt / 8));
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const band = Math.floor((s.x / 20) % bands);
        const shift = (band - bands / 2) * amt * 0.15;
        return { ...s, x: s.x + shift, y: s.y + Math.sin(band) * amt * 0.05 };
      });
    }
    function applyHelix(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const freq = 0.015;
      const spin = amt / 50;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const angle = s.x * freq + s.y * freq;
        const radius = Math.sin(angle) * amt * 0.3;
        return { ...s, x: s.x + Math.cos(angle * 2) * radius, y: s.y + Math.sin(angle) * radius };
      });
    }
    function applyEruption(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const lift = amt * 1.1;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const burst = (sampleNoise(s.x * 0.02, s.y * 0.02) - 0.5) * amt * 0.4;
        return { ...s, x: s.x + burst * 0.4, y: s.y - lift + burst };
      });
    }
    function applyGridlock(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const grid = Math.max(4, amt * 0.5);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const x = Math.round(s.x / grid) * grid;
        const y = Math.round(s.y / grid) * grid;
        const jitter = (sampleNoise(s.x * 0.04, s.y * 0.04) - 0.5) * grid * 0.5;
        return { ...s, x: x + jitter, y: y - jitter * 0.4 };
      });
    }
    function applyGeometryBreak(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const grid = Math.max(3, amt * 0.4);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const snapX = Math.round(s.x / grid) * grid;
        const snapY = Math.round(s.y / grid) * grid;
        const offset = (Math.random() - 0.5) * amt * 0.3;
        return { ...s, x: snapX + offset, y: snapY - offset * 0.5 };
      });
    }
    function applyDestruction(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const cell = Math.max(6, 90 - amt * 0.7);
      const shift = amt * 0.7;
      const drop = Math.min(0.85, amt / 160);
      const out = [];
      segs.forEach(cmd => {
        if (cmd.x === undefined) { out.push({ ...cmd }); return; }
        if (cmd.type === "M") { out.push({ ...cmd }); return; }
        const gx = Math.floor(cmd.x / cell);
        const gy = Math.floor(cmd.y / cell);
        const n1 = sampleNoise(gx * 0.6, gy * 0.6);
        const n2 = sampleNoise(gx * 0.6 + 20, gy * 0.6 - 40);
        if (n1 < drop) return;
        out.push({ ...cmd, x: cmd.x + (n1 - 0.5) * 2 * shift, y: cmd.y + (n2 - 0.5) * 2 * shift });
      });
      return out;
    }
    function applyAnomaly(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.02;
      const depth = amt * 0.9;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const n1 = sampleNoise(s.x * scale, s.y * scale);
        const n2 = sampleNoise((s.x + 250) * scale, (s.y - 340) * scale);
        const warp = (sampleNoise((s.x - 500) * scale, (s.y + 120) * scale) - 0.5) * depth;
        return {
          ...s,
          x: s.x + (n1 - 0.5) * 2 * depth + warp * 0.3,
          y: s.y + (n2 - 0.5) * 2 * depth - warp * 0.3
        };
      });
    }
    function applySplinter(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      return segs.map((s, i) => {
        if (s.x === undefined) return { ...s };
        const next = segs[i + 1] && segs[i + 1].x !== undefined ? segs[i + 1] : s;
        const angle = Math.atan2((next.y ?? s.y) - s.y, (next.x ?? s.x) - s.x);
        const perpX = -Math.sin(angle);
        const perpY = Math.cos(angle);
        const dist = (sampleNoise(s.x * 0.03, s.y * 0.03) - 0.5) * amt;
        return { ...s, x: s.x + perpX * dist, y: s.y + perpY * dist };
      });
    }
    function applyFlux(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const scale = 0.012;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const v1 = sampleNoise(s.x * scale, s.y * scale);
        const v2 = sampleNoise((s.x - 800) * scale, (s.y + 480) * scale);
        const angle = (v1 - v2) * Math.PI * 4;
        const magnitude = amt * (0.4 + v1);
        return {
          ...s,
          x: s.x + Math.cos(angle) * magnitude * 0.5,
          y: s.y + Math.sin(angle) * magnitude * 0.5
        };
      });
    }
    function applyDetonate(segs, amt) {
      if (!canvas || !amt) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2, cy = height / 2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const dx = s.x - cx;
        const dy = s.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const blast = (Math.random() * 0.6 + 0.7) * (amt + dist * 0.3);
        const jitter = (sampleNoise(s.x * 0.015, s.y * 0.015) - 0.5) * amt;
        return {
          ...s,
          x: s.x + (dx / dist) * blast + jitter,
          y: s.y + (dy / dist) * blast + jitter * 0.6
        };
      });
    }

    // ðŸ§µ FIBER Effect
    function applyFiber(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      return segs.map((s, i) => {
        if (s.x === undefined) return { ...s };
        const fiber = Math.floor(s.y / 15) + Math.floor(s.x / 20);
        const offset = (fiber % 7) * amt * 0.8;
        const pull = sampleNoise(fiber * 0.3, i * 0.1) * amt * 0.8;
        return { ...s, x: s.x + pull, y: s.y + Math.sin(fiber) * offset };
      });
    }

    // ðŸŽ® VOXEL Effect
    function applyVoxel(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const voxelSize = Math.max(8, 40 - amt * 0.3);
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const vx = Math.floor(s.x / voxelSize) * voxelSize + voxelSize / 2;
        const vy = Math.floor(s.y / voxelSize) * voxelSize + voxelSize / 2;
        const depth = sampleNoise(vx * 0.05, vy * 0.05) * amt * 0.3;
        return { ...s, x: vx + depth, y: vy - depth };
      });
    }

    // ðŸ“„ ORIGAMI Effect
    function applyOrigami(segs, amt) {
      if (!amt || !canvas) return segs.map(s => ({ ...s }));
      const { width, height } = getCanvasSize();
      const cx = width / 2;
      const folds = Math.floor(amt / 20) + 2;
      const foldHeight = height / folds;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const foldIdx = Math.floor(s.y / foldHeight);
        const foldProg = (s.y % foldHeight) / foldHeight;
        const isEven = foldIdx % 2 === 0;
        const foldAngle = isEven ? foldProg : (1 - foldProg);
        const comp = Math.pow(foldAngle, 1.5);
        const xShift = (s.x - cx) * (1 - comp * amt * 0.01);
        const yShift = foldProg * amt * 0.2 * (isEven ? 1 : -1);
        return { ...s, x: cx + xShift, y: s.y + yShift };
      });
    }

    // ðŸ“º STATIC Effect
    function applyStatic(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const intensity = amt * 1.5;
      return segs.map((s, i) => {
        if (s.x === undefined) return { ...s };
        const seed = sampleNoise(i * 123.456, s.x * 0.01 + s.y * 0.01) * 999;
        const glitch = sampleNoise(s.y * 0.02, seed * 0.001);
        if (glitch > 0.7) {
          const jumpX = (sampleNoise(seed, s.y) - 0.5) * intensity * 2;
          const jumpY = (sampleNoise(s.x, seed + 100) - 0.5) * intensity * 0.5;
          return { ...s, x: s.x + jumpX, y: s.y + jumpY };
        }
        const noise = (sampleNoise(s.x * 0.1, s.y * 0.1 + seed) - 0.5) * intensity * 0.3;
        return { ...s, x: s.x + noise, y: s.y + noise * 0.5 };
      });
    }

    // ðŸŒŒ AURORA Effect
    function applyAurora(segs, amt) {
      if (!amt) return segs.map(s => ({ ...s }));
      const waveStr = amt * 1.2;
      return segs.map(s => {
        if (s.x === undefined) return { ...s };
        const wave1 = Math.sin(s.x * 0.015 + s.y * 0.008) * waveStr;
        const wave2 = Math.sin(s.x * 0.008 - s.y * 0.012 + Math.PI / 3) * waveStr * 0.7;
        const wave3 = Math.sin(s.x * 0.012 + s.y * 0.015 + Math.PI / 2) * waveStr * 0.5;
        const shimmer = sampleNoise(s.x * 0.02, s.y * 0.02) * waveStr * 0.3;
        return { ...s, x: s.x + wave1 + wave3 + shimmer, y: s.y + wave2 + wave1 * 0.5 };
      });
    }

    const globalEffectHandlers = {
      wave: applyWave,
      zigzag: applyZigZag,
      noise: applyNoise,
      twist: applyTwist,
      bulge: applyBulge,
      shear: applyShear,
      ripple: applyRipple,
      shockwave: applyShockwave,
      turbulence: applyTurbulence,
      fracture: applyFracture,
      rupture: applyRupture,
      crumble: applyCrumble,
      smear: applySmear,
      glitch: applyGlitch,
      melt: applyMelt,
      disintegrate: applyDisintegrate,
      implode: applyImplode,
      explode: applyExplode,
      shred: applyShred,
      void: applyVoid,
      cyclone: applyCyclone,
      gravitywell: applyGravityWell,
      pulse: applyPulse,
      crystal: applyCrystal,
      slipstream: applySlipstream,
      warpfield: applyWarpField,
      splat: applySplat,
      fold: applyFold,
      scramble: applyScramble,
      storm: applyStorm,
      quake: applyQuake,
      curtain: applyCurtain,
      kaleido: applyKaleido,
      cluster: applyCluster,
      tangle: applyTangle,
      magnetic: applyMagnetic,
      plasma: applyPlasma,
      dust: applyDust,
      slice: applySlice,
      swirl: applySwirl,
      inkblot: applyInkblot,
      radiate: applyRadiate,
      scatter: applyScatter,
      sonar: applySonar,
      filament: applyFilament,
      ribbons: applyRibbons,
      perlinflow: applyPerlinFlow,
      fractal: applyFractal,
      tsunami: applyTsunami,
      circuit: applyCircuit,
      ghost: applyGhost,
      blaze: applyBlaze,
      shatter: applyShatter,
      orbital: applyOrbital,
      lattice: applyLattice,
      crush: applyCrush,
      spectrum: applySpectrum,
      helix: applyHelix,
      eruption: applyEruption,
      gridlock: applyGridlock,
      nebula: applyNebula,
      psycho: applyPsycho,
      wormhole: applyWormhole,
      entropy: applyEntropy,
      liquid: applyLiquid,
      anomaly: applyAnomaly,
      splinter: applySplinter,
      flux: applyFlux,
      detonate: applyDetonate,
      fiber: applyFiber,
      voxel: applyVoxel,
      origami: applyOrigami,
      static: applyStatic,
      aurora: applyAurora
    };

    function applyGlyphEffects(segs, eff) {
      let out = segs.map(s => ({ ...s }));
      if (eff.distortionType === "wave") out = applyWave(out, eff.distortionAmount);
      if (eff.distortionType === "zigzag") out = applyZigZag(out, eff.distortionAmount);
      if (eff.distortionType === "noise") out = applyNoise(out, eff.distortionAmount);
      if (eff.roughenAmount > 0) out = applyRoughen(out, eff.roughenAmount);
      return out;
    }
    function applyGlobalEffects(segs) {
      let out = segs.map(s => ({ ...s }));
      const handler = globalEffectHandlers[state.distortionType];
      if (handler) out = handler(out, state.distortionAmount);
      if (state.roughenEnabled && state.roughness > 0) out = applyRoughen(out, state.roughness);
      if (state.geometryBreak > 0) out = applyGeometryBreak(out, state.geometryBreak);
      if (state.destruction > 0) out = applyDestruction(out, state.destruction);
      return out;
    }
    function getRenderedSegments(g) {
      if (!g) return [];
      const segs = applyGlobalEffects(applyGlyphEffects(g.segments, g.effects));
      const limits = getSamplingLimits();
      if (countSegmentPoints(segs) > limits.maxPoints) {
        const minDist = Math.max(0.4, getSampleSpacing() * 0.6);
        return simplifySegments(segs, minDist, limits.maxPoints);
      }
      return segs;
    }

    /* --- Rendering --- */
    function renderAll() {
      setupCanvas();
      ctx.save();
      ctx.fillStyle = state.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      glyphs.forEach(g => {
        const distorted = getRenderedSegments(g);
        g.renderBounds = getGlyphBounds(g, distorted);
        drawGlyph(distorted, g);
      });
      glyphs.forEach(g => { if (g.selected) drawSelection(g); });
      ctx.restore();
      refreshGlyphList();
    }

    function drawGlyph(segs, g, offsetX = 0, offsetY = 0) {
      drawGlyphOnContext(ctx, segs, g, offsetX, offsetY);
    }
    function drawGlyphOnContext(targetCtx, segs, g, offsetX = 0, offsetY = 0) {
      targetCtx.save();
      targetCtx.translate(g.transform.x - offsetX, g.transform.y - offsetY);
      targetCtx.rotate(g.transform.rotation * Math.PI / 180);
      targetCtx.scale(g.transform.scaleX, g.transform.scaleY);
      targetCtx.beginPath();
      segs.forEach(cmd => {
        if (cmd.type === "M") targetCtx.moveTo(cmd.x - g.transform.x, cmd.y - g.transform.y);
        if (cmd.type === "L") targetCtx.lineTo(cmd.x - g.transform.x, cmd.y - g.transform.y);
        if (cmd.type === "C") targetCtx.bezierCurveTo(cmd.x1 - g.transform.x, cmd.y1 - g.transform.y, cmd.x2 - g.transform.x, cmd.y2 - g.transform.y, cmd.x - g.transform.x, cmd.y - g.transform.y);
        if (cmd.type === "Q") targetCtx.quadraticCurveTo(cmd.x1 - g.transform.x, cmd.y1 - g.transform.y, cmd.x - g.transform.x, cmd.y - g.transform.y);
        if (cmd.type === "Z") targetCtx.closePath();
      });
      targetCtx.lineCap = "round"; targetCtx.lineJoin = "round";
      targetCtx.strokeStyle = g.style.strokeColor || state.colorPrimary;
      targetCtx.lineWidth = g.style.strokeWidth || (state.size * 0.05 * state.strokeScale);
      targetCtx.stroke();
      targetCtx.restore();
    }

    /* --- Selection visuals --- */
    function getGlyphBounds(g, segOverride = null) {
      const source = segOverride || g.segments;
      const xs = [], ys = [];
      source.forEach(s => {
        ["x", "x1", "x2"].forEach(k => { if (s[k] !== undefined) xs.push(s[k]); });
        ["y", "y1", "y2"].forEach(k => { if (s[k] !== undefined) ys.push(s[k]); });
      });
      if (!xs.length || !ys.length) return null;
      let minX = Math.min(...xs), maxX = Math.max(...xs), minY = Math.min(...ys), maxY = Math.max(...ys);
      // apply transform
      const cx = g.transform.x, cy = g.transform.y, sx = g.transform.scaleX, sy = g.transform.scaleY, rot = g.transform.rotation * Math.PI / 180;
      const corners = [
        [minX, minY], [maxX, minY], [maxX, maxY], [minX, maxY]
      ].map(([x, y]) => {
        let dx = x - cx, dy = y - cy;
        let rx = dx * sx, ry = dy * sy;
        const rrx = rx * Math.cos(rot) - ry * Math.sin(rot);
        const rry = rx * Math.sin(rot) + ry * Math.cos(rot);
        return [rrx + cx, rry + cy];
      });
      const xs2 = corners.map(c => c[0]), ys2 = corners.map(c => c[1]);
      return { minX: Math.min(...xs2), maxX: Math.max(...xs2), minY: Math.min(...ys2), maxY: Math.max(...ys2), corners };
    }

    function drawSelection(g) {
      const b = g.renderBounds || getGlyphBounds(g, getRenderedSegments(g)); if (!b) return;
      ctx.save();
      ctx.strokeStyle = "#2563eb"; ctx.lineWidth = 1; ctx.setLineDash([4, 2]);
      ctx.strokeRect(b.minX, b.minY, b.maxX - b.minX, b.maxY - b.minY);
      ctx.setLineDash([]);
      const handles = [
        ...b.corners,
        [(b.minX + b.maxX) / 2, b.minY - 20] // rotation handle
      ];
      handles.forEach((h, i) => {
        ctx.fillStyle = i === 4 ? "#f97316" : "#2563eb";
        ctx.beginPath(); ctx.rect(h[0] - 5, h[1] - 5, 10, 10); ctx.fill();
      });
      ctx.restore();
    }

    /* --- Selection logic --- */
    function selectGlyph(glyph) {
      glyphs.forEach(g => g.selected = false);
      if (glyph) glyph.selected = true;
      selectedGlyph = glyph;
      updateInspector();
    }
    function selectGlyphById(id) {
      const g = glyphs.find(x => x.id === id);
      selectGlyph(g);
    }

    function updateInspector() {
      const g = selectedGlyph;
      const label = document.getElementById("selectedChar");
      if (label) label.textContent = g ? g.char : "â€“";
      if (!label) return;
      const setVal = (id, v) => { if (ui[id]) ui[id].value = v ?? ""; };
      if (!g) return;
      setVal("selPosX", g.transform.x.toFixed(1));
      setVal("selPosY", g.transform.y.toFixed(1));
      setVal("selScaleX", g.transform.scaleX.toFixed(2));
      setVal("selScaleY", g.transform.scaleY.toFixed(2));
      setVal("selRotation", g.transform.rotation.toFixed(1));
      setVal("selStrokeWidth", g.style.strokeWidth.toFixed(1));
      setVal("selStrokeColor", g.style.strokeColor);
      setVal("selEffectType", g.effects.distortionType);
      setVal("selEffectAmount", g.effects.distortionAmount);
    }

    function refreshGlyphList() {
      const ul = document.getElementById("glyphList");
      if (!ul) return;
      ul.innerHTML = "";
      glyphs.forEach((g, i) => {
        const li = document.createElement("li");
        li.textContent = `${i} â€“ ${g.char}`;
        li.dataset.id = g.id;
        if (g.selected) li.classList.add("selected");
        ul.appendChild(li);
      });
    }

    /* --- Layer ops --- */
    function moveLayer(id, dir) {
      const idx = glyphs.findIndex(g => g.id === id);
      if (idx < 0) return;
      const newIdx = idx + dir;
      if (newIdx < 0 || newIdx >= glyphs.length) return;
      const [g] = glyphs.splice(idx, 1);
      glyphs.splice(newIdx, 0, g);
      refreshGlyphList(); renderAll(); saveHistory();
    }
    function duplicateSelected() {
      if (!selectedGlyph) return;
      const clone = JSON.parse(JSON.stringify(selectedGlyph));
      clone.id = crypto.randomUUID();
      clone.transform.x += 20; clone.transform.y += 20;
      glyphs.push(clone);
      selectGlyph(clone); refreshGlyphList(); renderAll(); saveHistory();
    }
    function deleteSelected() {
      if (!selectedGlyph) return;
      const idx = glyphs.findIndex(g => g.id === selectedGlyph.id);
      if (idx >= 0) glyphs.splice(idx, 1);
      selectGlyph(glyphs[0] || null);
      refreshGlyphList(); renderAll(); saveHistory();
    }

    /* --- History --- */
    function saveHistory() {
      const snapshot = JSON.stringify({ glyphs, state });
      history.splice(historyIndex + 1);
      history.push(snapshot);
      historyIndex = history.length - 1;
    }
    function restoreFromSnapshot(snap) {
      const obj = JSON.parse(snap);
      Object.assign(state, obj.state);
      glyphs.length = 0; obj.glyphs.forEach(g => glyphs.push(g));
      selectedGlyph = null;
      refreshGlyphList();
      renderAll();
    }
    function undo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      restoreFromSnapshot(history[historyIndex]);
    }
    function redo() {
      if (historyIndex >= history.length - 1) return;
      historyIndex++;
      restoreFromSnapshot(history[historyIndex]);
    }

    /* --- Project export/import --- */
    function exportProject() {
      const data = JSON.stringify({ glyphs, state }, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "typolab_project.json";
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function importProject(e) {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        try {
          const obj = JSON.parse(ev.target.result);
          Object.assign(state, obj.state || {});
          glyphs.length = 0; (obj.glyphs || []).forEach(g => glyphs.push(g));
          selectGlyph(glyphs[0] || null);
          refreshGlyphList(); renderAll(); saveHistory();
        } catch (err) { console.error(err); alert("Import fehlgeschlagen."); }
      };
      reader.readAsText(file);
    }

    /* --- Canvas export --- */
    function startBrandFontCycle() {
      const el = document.querySelector(".brand-marquee");
      if (!el || !brandFonts.length) return;
      let idx = 0;
      setInterval(() => {
        idx = (idx + 1) % brandFonts.length;
        el.style.opacity = 0;
        setTimeout(() => {
          el.style.fontFamily = `"${brandFonts[idx]}", "Space Grotesk", sans-serif`;
          el.style.opacity = 1;
        }, 150);
      }, 1800);
    }

    function downloadGlyphImage() {
      if (!glyphs.length) return;
      const bounds = getSceneBounds();
      if (!bounds) return;
      const padding = 20;
      const width = Math.ceil((bounds.maxX - bounds.minX) + padding * 2);
      const height = Math.ceil((bounds.maxY - bounds.minY) + padding * 2);
      if (width <= 0 || height <= 0) return;
      const ratio = window.devicePixelRatio || 1;
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = width * ratio;
      exportCanvas.height = height * ratio;
      const exportCtx = exportCanvas.getContext("2d");
      exportCtx.scale(ratio, ratio);
      exportCtx.fillStyle = state.backgroundColor || "#ffffff";
      exportCtx.fillRect(0, 0, width, height);
      const offsetX = bounds.minX - padding;
      const offsetY = bounds.minY - padding;
      glyphs.forEach(g => {
        const distorted = getRenderedSegments(g);
        drawGlyphOnContext(exportCtx, distorted, g, offsetX, offsetY);
      });
      const link = document.createElement("a");
      link.href = exportCanvas.toDataURL("image/png");
      link.download = "monoline-glyph.png";
      link.click();
    }

    function ensureAlphabetGlyphs() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const missing = letters.split("").some(ch => !glyphs.find(g => g.char === ch));
      if (missing) {
        buildAlphabetFromTemplate();
        renderAll();
      }
    }

    function getExportCharacters() {
      const baseSets = [
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        "abcdefghijklmnopqrstuvwxyz",
        "0123456789",
        "Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ",
        `.,;:!?'"^~_-+=*/\\|@#$%&()[]{}<>`,
        " "
      ];
      const seen = new Set();
      const out = [];
      baseSets.forEach(set => {
        for (const ch of set) {
          if (seen.has(ch)) continue;
          seen.add(ch);
          out.push(ch);
        }
      });
      glyphs.forEach(g => {
        if (!g?.char || seen.has(g.char)) return;
        seen.add(g.char);
        out.push(g.char);
      });
      return out;
    }

    function hasSourceGlyph(ch) {
      if (state.font) {
        try {
          const g = state.font.charToGlyph(ch);
          if (!g) return false;
          if (g.name && g.name !== ".notdef") return true;
          if (g.unicode !== undefined && g.unicode !== null) return true;
          return false;
        } catch (e) { return false; }
      }
      if (state.svgFont) return !!state.svgFont.glyphs[ch];
      return false;
    }

    function createGlyphForExport(ch, template) {
      if (!hasSourceGlyph(ch)) return null;
      const baseX = 0;
      const baseY = state.size;
      const segs = state.font
        ? buildSegmentsFromOpenType(ch, baseX, baseY)
        : state.svgFont
          ? buildSegmentsFromSvg(ch, baseX, baseY)
          : [];
      if (!segs.length) return null;
      const glyph = new GlyphInstance(
        crypto.randomUUID(),
        ch,
        segs,
        { x: baseX, y: baseY, scaleX: 1, scaleY: 1, rotation: 0 },
        { strokeWidth: state.size * 0.05 * state.strokeScale, strokeColor: state.colorPrimary },
        { distortionType: "none", distortionAmount: 0, roughenAmount: 0 }
      );
      applyTemplateToGlyph(glyph, template);
      return glyph;
    }

    function transformPointToFont(x, y, glyph, scaleFactor) {
      let lx = (x - glyph.transform.x);
      let ly = (y - glyph.transform.y);
      lx *= glyph.transform.scaleX;
      ly *= glyph.transform.scaleY;
      const rot = glyph.transform.rotation * Math.PI / 180;
      const rx = lx * Math.cos(rot) - ly * Math.sin(rot);
      const ry = lx * Math.sin(rot) + ly * Math.cos(rot);
      return { x: rx * scaleFactor, y: -ry * scaleFactor };
    }

    function createOpenTypePathForGlyph(glyph, scaleFactor) {
      const limits = getSamplingLimits();
      const exportMinDist = Math.max(0.5, getSampleSpacing() * 0.8);
      const segs = simplifySegments(getRenderedSegments(glyph), exportMinDist, limits.maxExportPoints);
      const polylines = flattenSegmentsToPolylines(segs)
        .map(line => simplifyPolyline(line, exportMinDist, limits.maxPolylinePoints))
        .filter(line => line.length > 1);
      const strokeWidth = glyph.style?.strokeWidth || (state.size * 0.05 * state.strokeScale);
      const path = new opentype.Path();
      const half = Math.max(0.5, strokeWidth / 2);
      polylines.forEach(line => {
        const polygon = createStrokePolygons(line, half);
        if (polygon.length < 3) return;
        polygon.forEach((pt, idx) => {
          const p = transformPointToFont(pt.x, pt.y, glyph, scaleFactor);
          if (idx === 0) path.moveTo(p.x, p.y); else path.lineTo(p.x, p.y);
        });
        path.close();
      });
      return path;
    }

    function glyphToOpenTypeGlyph(glyph, scaleFactor) {
      const path = createOpenTypePathForGlyph(glyph, scaleFactor);
      const advanceWidth = getAdvanceWidthCanvas(glyph.char) * scaleFactor;
      return new opentype.Glyph({
        name: glyph.char,
        unicode: glyph.char.charCodeAt(0),
        advanceWidth,
        path
      });
    }

    function createNotdefGlyph(unitsPerEm) {
      return new opentype.Glyph({
        name: ".notdef",
        advanceWidth: Math.round(unitsPerEm * 0.5),
        path: new opentype.Path()
      });
    }

    function exportAlphabetFont() {
      if (!state.font && !state.svgFont) {
        alert("Bitte zuerst einen Font laden.");
        return;
      }
      let fontName = prompt("Wie soll der Font heiÃŸen?", state.customFontName || "TypoLab Custom");
      if (fontName === null) return;
      fontName = fontName.trim();
      if (!fontName) fontName = "TypoLab Custom";
      state.customFontName = fontName;
      const unitsPerEm = state.font?.unitsPerEm || state.svgFont?.unitsPerEm || 1000;
      const scaleFactor = unitsPerEm / (state.size || 1);
      const otGlyphs = [createNotdefGlyph(unitsPerEm)];
      const template = getStyleTemplate();
      const exportChars = getExportCharacters();
      const glyphMap = new Map();
      glyphs.forEach(g => {
        if (g?.char && !glyphMap.has(g.char)) glyphMap.set(g.char, g);
      });
      exportChars.forEach(ch => {
        let g = glyphMap.get(ch);
        if (!g) g = createGlyphForExport(ch, template);
        if (!g) return;
        otGlyphs.push(glyphToOpenTypeGlyph(g, scaleFactor));
      });
      if (otGlyphs.length <= 1) {
        alert("Keine Glyphen zum Export gefunden.");
        return;
      }
      const ascender = state.font?.ascender ?? (unitsPerEm * 0.8);
      const descender = state.font?.descender ?? (-unitsPerEm * 0.2);
      try {
        const font = new opentype.Font({
          familyName: fontName,
          styleName: "Regular",
          unitsPerEm,
          ascender,
          descender,
          glyphs: otGlyphs
        });
        const buffer = font.toArrayBuffer();
        const blob = new Blob([buffer], { type: "font/otf" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        const fileSafe = fontName.replace(/\s+/g, "_").replace(/[^A-Za-z0-9_\-]/g, "") || "TypoLab_Custom";
        link.download = `${fileSafe}.otf`;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error(err);
        alert("Font-Export fehlgeschlagen. Tipp: Sampling reduzieren und erneut exportieren.");
      }
    }

    /* --- Canvas interaction --- */
    function bindCanvasInteraction() {
      canvas.addEventListener("mousedown", onDown);
      canvas.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }

    function hitTestGlyph(x, y) {
      // simple bbox hit
      for (let i = glyphs.length - 1; i >= 0; i--) {
        const g = glyphs[i]; const b = getGlyphBounds(g); if (!b) continue;
        if (x >= b.minX && x <= b.maxX && y >= b.minY && y <= b.maxY) return { glyph: g, bounds: b };
      }
      return null;
    }

    function hitTestHandle(g, x, y) {
      const b = getGlyphBounds(g); if (!b) return null;
      const handles = [...b.corners, [(b.minX + b.maxX) / 2, b.minY - 20]];
      for (let i = 0; i < handles.length; i++) {
        const [hx, hy] = handles[i];
        if (Math.abs(x - hx) <= 8 && Math.abs(y - hy) <= 8) return i === 4 ? "rotate" : "scale";
      }
      return null;
    }

    function onDown(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const hit = hitTestGlyph(x, y);
      if (hit) {
        selectGlyph(hit.glyph);
        activeHandle = hitTestHandle(hit.glyph, x, y);
        if (activeHandle === "rotate") dragMode = "rotate";
        else if (activeHandle === "scale") dragMode = "scale";
        else dragMode = "move";
        dragStart = { x, y, gx: hit.glyph.transform.x, gy: hit.glyph.transform.y, gscaleX: hit.glyph.transform.scaleX, gscaleY: hit.glyph.transform.scaleY, grot: hit.glyph.transform.rotation };
      } else {
        selectGlyph(null);
        dragMode = null;
      }
      renderAll();
    }

    function onMove(e) {
      if (!dragMode || !selectedGlyph) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const dx = x - dragStart.x;
      const dy = y - dragStart.y;
      if (dragMode === "move") {
        selectedGlyph.transform.x = dragStart.gx + dx;
        selectedGlyph.transform.y = dragStart.gy + dy;
      }
      if (dragMode === "scale") {
        const factor = 1 + dx / 200;
        selectedGlyph.transform.scaleX = Math.max(0.1, dragStart.gscaleX * factor);
        selectedGlyph.transform.scaleY = Math.max(0.1, dragStart.gscaleY * factor);
      }
      if (dragMode === "rotate") {
        const cx = dragStart.gx, cy = dragStart.gy;
        const angle = Math.atan2(y - cy, x - cx) * 180 / Math.PI;
        selectedGlyph.transform.rotation = angle;
      }
      updateInspector();
      scheduleRender();
    }

    function onUp() {
      if (dragMode) { saveHistory(); }
      dragMode = null; activeHandle = null; dragStart = null;
    }

    /* --- History init --- */
    saveHistory();
  </script>
</body>

</html>x
